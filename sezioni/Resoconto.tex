\section{Resoconto dello stage}
\subsection{Pianificazione di progetto}
\subsubsection{Descrizione generale}
Come gi\`a detto in precedenza, lo stage \`e stato suddiviso in due parti: la prima orientata alla formazione su strumenti e tecnologie e la seconda parte orientata alla realizzazione di progetti destinati ai clienti esterni. Come tale, l’attività di formazione \`e stata opportunamente orientata all’apprendimento, da parte mia, delle meccaniche e delle norme vigenti internamente per lo sviluppo di tali progetti, oltre che alla normale parte di formazione tecnica prevista per portare a termine in maniera opportuna le attività dei progetti stessi.
L’obiettivo finale dello stage \`e stato quindi quello di inserirmi come parte integrante del team di sviluppo per i progetti esterni, attribuendomi responsabilità e compiti adeguati al mio ruolo e orientati alle attività di produzione, testing e delivery di app mobile di Realtà Aumentata; la valutazione finale da parte del tutor aziendale \`e stata quindi effettuata sulla base sia della qualità sia della quantità delle attività portate a termine nella fase produttiva finale, oltre che alla capacità di lavorare correttamente in squadra con l’obiettivo comune di consegnare un prodotto finale nei tempi e nelle modalità stabilite.
\\\\
Nel periodo antecedente l'inizio dello stage, insieme al tutor aziendale, sono state concordate le attivit\`a principali che avrei dovuto svolgere durante il periodo seguente della durata di 2 mesi. Nella descrizione delle attivit\`a, riportata nella sezione successiva, \`e stata fornita una descrizione molto generica per quanto riguarda il progetto principale che avrei dovuto seguire in quanto non era ancora chiaro a priori se ci sarebbe stata o meno la possibilit\`a di seguire un progetto commissionato dall'esterno.
\\\\
La dislocazione temporale delle attivita \`e stata rappresentata graficamente in un Diagramma di Gantt che mi ha aiutato ad avere sempre una visione accurata sullo stato del mio stage, in particolare su eventuali ritardi. Rispetto al diagramma concordato nel piano di lavoro, il mio stage \`e partito dopo 2 giorni rispetto a quanto concordato a causa di un'indisponibilit\`a del tutor aziendale, per cui \`e stata rifatta la pianificazione tenendo conto di questo ritardo.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.1\textwidth]{\docsImg Gantt.png}
	\caption{Diagramma di Gantt delle attivita'}
	\label{fig:Diagramma di Gantt delle attivita}
\end{figure}

Il Diagramma di Gantt riportato in figura \ref{fig:Diagramma di Gantt delle attivita} mostra piuttosto fedelmente quanto svolto durante il periodo in azienda ed eventuali anticipi sulla tabella di marcia sono stati riempiti con approfondimenti sulle tecnologie e sessioni di ricerca e sviluppo su visori Google Cardboard. Non ci sono stati, invece, ritardi su quanto preventivato.

\subsubsection{Dettaglio delle attivit\`a}
Di seguito vengono elencate in dettaglio le attivit\`a svolte durante il periodo di stage svolto presso l'azienda ospitante Experenti. Un approfondimento per le principali. 

\begin{enumerate}
	\item	Formazione sulle tecnologie utilizzate internamente per lo sviluppo, quali framework e SDK. In particolare:
	
	\begin{enumerate}	
		\item	Ambiente di sviluppo (IDE) utilizzato (Unity3D) e fondamenti dei sistemi operativi mobile (Android e iOS); 
		\item	Formazione sulle librerie utilizzate internamente per l’elaborazione delle immagini per la realtà aumentata e per il successivo riconoscimento delle stesse in ambiente mobile; 
		\item	Formazione sull’app Experenti: nascita del progetto, funzionamento attuale, obiettivi di sviluppo. Formazione sulle procedure standard applicate internamente.	
	\end{enumerate}
	
	\item	Realizzazione di un esempio di contenuto in Realtà Aumentata a tema libero. Questo contenuto, il cui sviluppo è stato necessario alla comprensione del flusso di lavoro interno e all'individuazione di determinate problematiche relative all’ambito AR mobile, ha particolari caratteristiche, quali animazioni e/o movimenti di parti specifiche, un certo grado di interattività e prevede parti semplici di grafica GUI (su schermo, in modalità HUD). E' stata richiesta, inoltre, l’individuazione di un tag adatto al riconoscimento dalle fotocamere mobile, possibilmente legato alla tematica che \`e stata sviluppata.
	\item	Analisi di casi di studio e app varie già realizzate internamente. Focus particolare sui progetti base già realizzati e sulla loro struttura: progetto base demo, progetto base visore AR, progetto base configuratore. In questa fase \`e avvenuta la formazione sul flusso di lavoro standard interno all’azienda e sul normale iter di un progetto commissionato da un cliente, dalla ricezione dei materiali fino alla fase di distribuzione (sia essa una distribuzione ad hoc o una distribuzione pubblica tramite Store mobile) ed \`e iniziato l'affiancamento al Project Manager nelle fasi di accettazione materiali. 
	\item	Realizzazione di un’app demo completa. Per app demo si intende un’app a distribuzione solitamente ad hoc (non pubblicata sugli Store) resa disponibile dall’azienda per i propri clienti o reseller, comprendente un numero solitamente limitato di contenuti semplici (3D o video) fruibili dall’utente in realtà aumentata attraverso l’uso di un tag fornito dal cliente stesso. L’app possiede, inoltre, una GUI minimale ma personalizzata con il logo del cliente stesso, nonchè un’icona e una splashscreen anch’esse personalizzate allo stesso modo. Richiesto l'affiancamento al Project Manager fin dalla fase iniziale di ricezione materiali, e prosecuzione poi in autonomia nella fase di sviluppo fino alla fase di rilascio e consegna (previa verifica del risultato prodotto da parte del Tutor Aziendale). L’entità dell’app demo \`e stata stabilita dal Project Manager aziendale alcuni giorni prima dell’inizio di questa fase e si \`e data preferenza, alla produzione di una demo per un cliente esterno. 
	\item	Inserimento effettivo nel team di sviluppo per i progetti esterni. In questa fase, inizia l'affiancamento al team di sviluppo per i progetti commissionati dai clienti esterni; \`e iniziato quindi il coordinamento dal Project Manager aziendale nell’assegnazione di task appositi comprendenti le fasi di sviluppo e testing di intere app semplici o parti di app complesse; si \`e preferito assegnare la realizzazione di almeno un’app semplice nella sua interezza commissionata da un cliente esterno. L’assegnazione delle attività \`e stato effettuato attraverso il sistema di ticketing utilizzato internamente all’azienda, attraverso il quale \`e stato anche richiesto di rendicontare le proprie attività in termini di tempo utilizzato per ciascuna di esse, mentre l’assegnazione dei singoli task \`e stata effettuato dal Project Manager aziendale in collaborazione con il tutor aziendale. E' stato valutato positivamente in questa fase la capacità di attenersi alle tempistiche date e il livello di dettaglio fornito nella successiva rendicontazione delle ore, oltre ovviamente alla qualità intrinseca del risultato prodotto. 
\end{enumerate}

\begin{center}
	
	\begin{longtable}{c| p{0.7\textwidth}| c}

		\textbf{Sezione} & \textbf{Descrizione} & \textbf{Ore di lavoro}\\ \cline{1-3}
		\phantomsection
		1.1&  Formazione su ambienti di sviluppo&  40 \\
				\phantomsection
		1.2&  Formazione su librerie utilizzate&  28 \\
				\phantomsection
		1.3&  Formazione sull’app Experenti&  12 \\
				\phantomsection
		2&  Realizzazione di un contenuto di realtà aumentata a tema libero&   56\\	
				\phantomsection
		3&  Analisi su progetti già realizzati internamente e formazione su flusso di lavoro interno&   40\\
				\phantomsection	
		4&  Realizzazione di un’app demo completa&   24\\
				\phantomsection					
		5&  Inserimento nel team di sviluppo e realizzazione di un’app nella sua interezza&   120\\ \cline{1-3}
				\phantomsection
		  & \textbf{TOTALE} & \textbf{320}  \\\\
		  		\caption{Tabella relativa alle ore dedicate per ciascuna attivit\`a}\\
	\end{longtable}
		
\end{center}

\subsection{Studio delle tecnologie e strumenti}
In questa sezione, vengono spiegate le attivit\`a di apprendimento svolte per imparare l'utilizzo delle nuove tecnologie e degli strumenti usati.
\subsubsection{Unity 3D}
Unity, come gi\`a detto in precedenza \`e un sistema cross-platform per lo sviluppo di giochi composto da un game engine e da un IDE integrato. Unity viene usato internamente all'azienda per lo sviluppo di app mobile distribuite su Android e iOS.
\\
Unity nel suo sito fornisce un grosso supporto agli sviluppatori fornendo una documentazione completa e una sezione ben fornita di tutorial testuali e video suddivisi per categoria.\\
Inizialmente, ho dovuto seguire una parte di video tutorial riguardanti l'interfaccia di Unity, lo scripting, la gestione della fisica, animazioni e gestione della GUI. Questa primo periodo si \`e svolto integrando, oltre alla visione, anche la prova diretta sull'editor in modo da assimilare meglio i concetti appresi.\\
Nel caso in cui volessi approfondire un argomento oppure non lo ritenessi abbastanza chiaro, avevo sempre la possibilit\`a di ottenere una spiegazione da parte del tutor aziendale, il quale si \`e dimostrato sempre molto disponibile anche nel ripetere pi\`u volte lo stesso concetto.\\
In questa parte di formazione, dopo aver seguito e implementato un tutorial riguardante l'animazione di un avatar, di mia iniziativa, ho effettuato il porting dell'applicazione su Android gestendo touch e multi-touch sullo schermo e impostando i movimenti dell'avatar basandoli sull'acelerometro del dispositivo mobile.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg tutorial.jpg}
	\caption{Implementazione in Unity del tutorial riguardante l'animazione di un avatar 3D di cui successivamente \`e stato eseguito il porting su Android}
	\label{fig:tutorial riguardante l'animazione di un avatar 3D}
\end{figure}
 
\subsubsection{Vuforia SDK}
Terminata la parte di formazione su Unity 3D, \`e iniziata la parte di preparazione relativa a Vuforia SDK, l'SDK utilizzato dall'azienda per l'implementazione della realt\`a aumentata. Nello specifico, il team tecnico si \`e occupato di spiegarmi come funziona l'SDK, e come funziona nello specifico il plugin di Unity, grazie alla quale è possibile operare all’interno di un unico ambiente di lavoro. Le attivit\`a principali svolte in questo lasso di tempo sono state l'implementazione di modelli 3D e di video associati ai tag, e lo studio sul riconoscimento e la creazione di tag ottimali.

\subsubsection{Photon Unity Networking}
Photon Unity Networking (PUN) \`e un framework di Unity per l'implementazione del multiplayer realtime neigiochi o nelle applicazioni sviluppate. Le applicazioni svilupapte con Photon vengono eseguite su un server cloud proprietario. Quindi, le operazioni di scaling e di service hosting sonogestite interamente da PUN, permettendo allo sviluppatore di concentrarsi puramente sulla costruzione dell'applicazione. Tutti i prodotti Photon Cloud sono basati su un'architettura client-to-server, che \`e la soluzione ottimale per il gaming onlire rispetto a una connessione peer-to-peer.\\
Photon \`e un package scaricabile dall'Asset Store (negozio di Unity online in cui comprare o scaricare gratuitamente asset come script, modelli 3D e 2D, etc.), e nella sua versione gratuita prevede l'accesso concorrente fino a 20 utenti sulla stessa stanza. \\\\
Di seguito vengono riportati esempi di codice per mostrare la semplicit\`a di utilizzo del framework.\\
\begin{itemize}
	\item \textbf{Connessione al server}: La connessione al server si basa sul passaggio di una stringa contenente la versione dell'applciazione. Pu\`o essere usata per dividere gruppi di client.
\begin{lstlisting}
PhotonNetwork.ConnectUsingSettings("1.0");
\end{lstlisting}

	\item \textbf{Accesso a una stanza}: Per prendere parte a una partita esistente basta la seguente riga di codice specificando il nome della stanza in cui si vuole entrare.
\begin{lstlisting}
PhotonNetwork.JoinRoom("RoomName");
\end{lstlisting}

	\item \textbf{Creare una stanza}: per creare una stanza basta fornire il nome, dare la possibilit\`a o meno di essere trovata da altri utenti, fornire la possibilit\`a agli altri di entrare, e il numero massimo di giocatori.
\begin{lstlisting}
public void OnConnectedToMaster(){
	PhotonNetwork.CreateRoom("RoomName", true, true, 4);
}

\end{lstlisting}	
	
\end{itemize}

Lo studio di Photon Unity Networking non mi \`e stato imposto dall'azienda, ma \`e stato un approfondimento che ho voluto fare di mia iniziativa per lo sviluppo dell'esempio di contenuto in realt\`a aumentata a tema libero di cui parler\`o successivamente.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{\docsImg Photon.png}
	\caption{Architettura generale del framework Photon Unity Networking}
	\label{fig:Architettura generale del framework Photon Unity Networking}
\end{figure}

PUN si \`e dimostrato uno strumento molto potente e relativamente di facile utilizzo. Creare un semplice scambio di dati tra diversi client \`e risultato piuttosto semplice. Il livello di difficolt\`a \`e salito quando ho cercato di aumentare il numero di informazioni passate e il numero di oggetti da "osservare". Essendo uno studio non richiesto dall'azienda, ho preferito non spendere troppo tempo in approfondimenti ma piuttosto avere un'idea chiara del funzionamento di base.

\subsubsection{Esempio di contenuto in realt\`a aumentata a tema libero}
Come ultimo passo a compimento del percorso di preparazione tecnologica e strumentale, e prima di iniziare la realizzazione del progetto principale di stage, mi \`e stato chiesto di sviluppare un'applicazione completa con dei contenuti non banali in realt\`a aumentata. Ci\`o che mi \`e stato reso disponibile per la realizzazione dell'app oltre a Unity 4.6.3 e Vuforia SDK 4, sono stati anche tutti i contenuti gratuiti disponibili sull'Asset Store. Ho quindi proceduto con un'accurata scansione dei contenuti scaricabili trovando ci\`o che fosse pi\`u utile per dare luce all'idea ins tato embrionale che avevo in mente.\\\\
Quello che stavo cercando erano dei modelli 3D in stile "cartoon" per lo sviluppo di un videogioco sparatutto multiplayer in realt\`a aumentata.\\
L'idea che volevo implementare era dare la possibilit\`a a pi\`u utenti di interagire sullo stesso tag, e rendere tali interazioni visibili ad utenti che si trovassero dall'altra parte del mondo. La prima idea che mi era venuta, era quella di gestire un oggetto 3D e dare la possibilit\`a di modificarne la struttura, il colore e la scala agli utenti, in modo che i cambiamenti fossero visibili a tutti gli utenti in osservazione su quel dato tag. Questo per\`o non mi \`e bastato, in quanto volevo vedere fino a che punto si poteva spingere un device Android con il rendering di contenuti in realt\`a aumentata. Per cui la realizzazione di un gioco mi sembrava perfetta per testare questi due aspetti.\\

Come gi\`a detto ho effettuato uno studio di Photon Unity Networking per l'implementazione del multiplayer e successivamente ho proceduto con una semplice progettazione architetturale e con l'implementazione vera e propria.\\

La prima cosa fatta \`e stata la realizzazione della mappa di gioco, cercando di renderla il pi\`u simmetrica possibile in modo da non sfavorire nessuno dei due giocatori e creando delle barriere invisibili per non permettere ai giocatori di poter uscire dallo scenario.\\
Il passo successivo \`e stato quello di creare dei punti di respawn e di gestire la nascita dei giocatori in modo casuale sulla mappa. Avendo trovato sull'Asset Store un modello 3D gi\`a in possesso di animazioni e script che simulassero un soldato cartoon vero e proprio, non ho dovuto occuparmid ella gestione dell'avatar.\\
Una volta creati e gestiti i punti di respawn, \`e iniziato il lavoro di configurazione della lobby (contenitore di stanze) in primo luogo, e delle stanze successivamente, fornendo la possibilit\`a ai giocatori di creare la propria stanza e di vedere le stanze create dagli altri giocatori. Per la lobby \`e stata creata una schermata iniziale apposita di scelta dello username e di creazione nuova stanza o accesso a una stanza gi\`a creata.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{\docsImg cot3.jpg}
	\caption{Schermata iniziale di Call Of Toony con Lobby}
	\label{fig:Schermata iniziale di Call Of Toony con Lobby}
\end{figure}

Inseguito, sono stati gestiti gli script relativi al passaggio dei dati attraverso la rete. In particolare i dati passati sono:

\begin{itemize}
	\item posizione e rotazione dei personaggi rispetto alla mappa;
	\item percentuale di salute rimasta sulla health bar;
	\item bersaglio colpito e chi ha colpito il bersaglio.
\end{itemize}

La gestione di questi dati ha permesso la gestione di un gioco basilare, in cui successivamente \`e stata applicata un'area in cui rappresentare i log della partita, quali: spawn dei giocatori e le uccisioni avvenute. Inoltre, localmente \`e stato reso disponibile il numero di morti del proprio personaggio, mentre non c'\`e stato abbastanza tempo per gestire anche il numero di uccisioni.\\\\
Il risultato \`e stato un gioco fluido e ben strutturato, in grado di gestire il multiplayer ad una latenza bassissima e in grado di coinvolgere il giocatore in un'esperienza nuova e unica. I problemi riscontrati sono dovuti unicamente ai device, i quali a lungo termine presentano surriscaldamento, consumo elevato di batteria e un calo di frame per secondo.\\
Il progetto \`e piaciuto molto al team tecnico, che non ha escluso la possibilit\`a, dopo un'accurata ottimizzazione, di un inserimento del contenuto in realt\`a aumentata all'interno dell'app Experenti.\\
Il nome del gioco \`e \textbf{Call Of Toony}, in richiamo a titoli videoludici del genere ben pi\`u noti.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg cot1.jpg}
	\caption{Call Of Toony - multiplayer su device diversi}
	\label{fig:Call Of Toony - multiplayer}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg cot2.jpg}
	\caption{Call Of Toony - schermata di gioco}
	\label{fig:Call Of Toony - schermata di gioco}
\end{figure}

\subsection{Svolgimento delle attivit\`a}
Inizia ora la stesura di quanto svolto nel progetto vero e proprio, ripercorrendo tutte le fasi del ciclo di vita del software sviluppato fino al suo rilascio sui vari store. Per lo svolgimento del progetto sono state previste circa 120 ore inserite all'interno dell'orario di lavoro aziendale, dal lunedi al venerdi.\\
Il nome dell'applicazione da sviluppare \`e Cor\`a Parquet Live.\\
Lo studio di fattibilit\`a \`e stato fatto dal Project Manager insieme a un collega del reparto tecnico, ed io non ne ho potuto prendere parte.

\subsubsection{Il cliente}
Prima di procedere con gli aspetti tecnici \`e bene avere una panoramica su chi \`e il cliente che ha commissionato la realizzazione del progetto, quale target di pubblico punta a raggiungere e quali sono le sue aspettative.
\\\\
Il cliente in questione \`e \textbf{Cor\`a Divisione Parquet}, una divisione dell'azienda \textbf{Cor\`a Legnami}, nata nel 1919. Cor\`a Parquet \`e specializzata nella realizzazione di pavimenti in legno e realizza pavimentazioni per ambienti interni, ambienti esterni e spazi pubblici. L'azienda, leader nel settore, punta a raggiungere i suoi clienti attraverso canali innovativi grazie alla spinta al ringiovanimento voluta da Ettore Cor\`a, amministratore delegato presso Cor\`a Domenico \& Figli SpA.\\
La richiesta del cliente era la realizzazione di un configuratore in realt\`a aumentata di pavimentazioni in legno, in grado di essere utilizzato inizialmente a scopo fieristico e successivamente utilizzabile dai clienti finali dell'azienda in modo da avere uno strumento in grado di fare provare le varie linee di prodotto direttamente nelle case dei possibili clienti.\\
Uno degli obiettivi era quello di fare scaturire nel possibile cliente ci\`o che viene chiamato "fattore wow", lasciando sbalordito il cliente e consolidando nella sua mente la propensione dell'azienda verso l'innovazione e il miglioramento.
Il secondo obiettivo \`e dato dal fatto che un'applicazione di un tale livello innovativo inevitabilmente produce un passaparola dagli utenti verso chi ancora non ha visto l'applicazione, generando quindi pubblicit\`a e maggiore visibilit\`a all'azienda.\\
Per generare questo "effetto wow", Cor\`a ha deciso di farsi realizzare un modello tridimensionale di una pin-up con un vestito dilegno. Questo avatar avrebbe dovuto presentare le varie linee di prodotto ed eseguire una introduzione all'applicazione. Il modello e le animazioni non sono state realizzate internamente all'azienda ma sono state delegate a terzi.\\\\
Infine, per quanto riguarda il target dell'app, ci si voleva rivolgere all'utente medio, in grado di poter stampare autonomamente il tag a casa propria. Visto che l'utente finale avrebbe dovuto essere la cosiddetta "signora Maria", ossia un utente senza particolare propensione per tecnicismi informatici e tecnologia in generale, l'applicazione doveva avere un elevato grado di usabilit\`a e doveva guidare l'utente passo passo.

\subsubsection{Analisi dei requisiti}
Nella metodologia Agile, l'insieme totale dei requisiti \`e ottenibile esclusivamente nelle ultime iterazioni, o comunque a progetto quasi ultimato. Questo perch\`e l'obiettivo principale del modello Agile \`e quello di ottenere il massimo soddisfacimento del cliente nei tempi e nei costi preventivati.\\
Alcuni aspetti di rifinitura sono stati quindi concordati in iterazioni intermedie, e sono stati accettati anche se cambiavano molto la struttura del progetto, purch\`e comunque non si avesse un totale stravolgimento di quanto fatto fino a quel punto.\\
Dopo un'attenta analisi iniziale, sono stati estrapolati i casi d'uso principali dalle richieste del committente, da uno studio sull'utenza finale e basandosi sull'user story.\\
L'analisi dei requisiti \`e stata svolta insieme alla Project Manager, la quale a mantenuto i contatti con il responsabile d'azienda esterno per tutta la durata del progetto. Insieme a lei abbiamo stilato una lista di funzionalit\`a prioritarie e una lista, invece, di requisiti desiderabili e opzionali.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg casi.png}
	\caption{Diagramma dei casi d'uso generico relativo all'applicazione Cora' Parquet Live}
	\label{fig:Diagramma dei casi d'uso generico relativo all'applicazione Cora' Parquet Live}
\end{figure}

Per quanto riguarda i requisiti, essi sono stati suddivisi in 3 categorie: requisiti obbligatori, requisiti opzionali e requisiti desiderabili.\\
Per quanto riguarda i requisiti opzionali, essi sono stati resi obbligatori dall'applicazione dei vincoli metodologici derivati dalle pratiche in uso aziendali.\\\\
Segue ora una lista descrittiva dei principali requisiti. Il presente documento vuole garantire un discreto livello di dettaglio senza annoiare il lettore, per cui verranno elencate solo le funzionalit\`a principali.\\\\

\textbf{Requisiti obbligatori:}

\begin{itemize}
	
	\item L'applicazione deve eseguire una presentazione iniziale dell'avatar, il quale deve comparire dietro un ventaglio di legno che si apre e deve fare un breve discorso di apertura.
	
	\item L'applicazione deve rendere disponibile un tutorial iniziale che spieghi tutte le funzionalit\`a dell'app.
	
	\item L'applicazione deve dare la possibilit\`a all'utente di sfogliare una lista di categorie di prodotto, suddivise alla radice in  "Linea di prodotto" e "Colori", che permetteranno di accedere agli stessi prodotti in due modi diversi. La lista deve essere navigabile in entrambe le direzioni (da padre a figlio e da figlio a padre).
	
	\item Quando una linea di prodotto viene selezionata deve essere data la possibilit\`a all'utente di avviare una breve presentazione eseguita dall'avatar sulla linea di prodotto scelta. Questo comporta l'apparazione dell'avatar a schermo.
	
	\item L'applicazione deve dare la possibilit\`a all'utente di visualizzare i prodotti appartenenti a una certa categoria e deve dare la possibilit\`a di selezionarne uno da visualizzare in realt\`a aumentata.
	
	\item L'utente deve avere la possibilit\`a di selezionare un prodotto da una lista di prodotti e di visualizzarlo in realt\`a aumentata agganciato al tag. Alla selezione del prodotto deve, inoltre, essere disponibile la possibilit\`a di visualizzare la descrizione del prodotto scelto in un pannello appositamente creato.
	
	\item L'applicazione deve permettere, quando un prodotto \`e selezionato e visibile in realt\`a aumentata, di effettuare modifiche sulla superficie coperta. In particolare, si vuole rendere disponibile all'utente la funzionalit\`a di pinch-to-scale sull'oggetto parquet.
	
	\item l'applicazione rende disponibile un men\`u di "Credits" in cui \`e possibile riavviare la presentazione iniziale, rivedere il tutorial, oppure collegarsi alla pagina di download tag, o alla pagina Facebook ufficiale di Cor\`a Divisione Parquet.
	
	\item L'applicazione deve dare la possibilit\`a all'utente di richiedere un preventivo online e di scattare uno screenshot della schermata visualizzata.
	
	\item L'applicazione deve contenere almeno i primi 30 prodotti inviati dall'azienda. 
	
\end{itemize}

\textbf{Requisiti desiderabili:}

\begin{itemize}
	\item L'applicazione deve contenere i 21 prodotti inviati in seconda istanza.
	
	\item L'applicazione deve prevedere le gesture di "Swipe" per aprire e chiudere i men\`u.
	
	\item Le texture dei prodotti devono utilizzare uno shader speculare per ottenere un'effetto piu lucido.
	
	\item La barra del men\`u di navigazione deve essere ingrandita rispetto alla versione base del configuratore.
	
	\item Gli screenshot devono catturare solo la schermata principale con il prodotto in realt\`a aumentata, il pannellodescrittivo del prodotto e il logo di Cor\`a Divisione Parquet, niente altro.
\end{itemize}

Come gi\`a descritto in precedenza, i requisiti hanno visto modifiche anche sostanziali ad ogni iterazione, questo perch\`e la pratica adottata \`e stata un'analisi iniziale seguita da una breve progettazione e da un intenso periodo di implementazione. Al termine di tale periodo, avveniva prima una verifica completa e poi compilata una demo ed inviata al cliente. Il cliente visionava l'app e inviava di ritorno al Project Manager un feedback con le criticit\`a e le migliorie da apportare. Seguiva, quindi un'ulteriore analisi dei requisiti ed iniziava un nuovo ciclo iterativo.\\\\


\subsubsection{Progettazione}
Nella metodologia Agile, la fase di progettazione \`e la pi\`u importante e difficile da realizzare. Serve infatti molta esperienza per lavorare con una metodologia di questo tipo, in quanto il progetto si ritrova soggetto a continui cambiamenti. Risulta quindi difficile una progettazione solida e duratura, e non si ha il tempo necessario per entrare nel dettaglio, in quanto le ore previste per questa attivit\`a sono poche e frequenti.\\
Come gi\`a detto in sezioni precedenti del documento, il configuratore da realizzare doveva partire da un modello di configuratore di base gi\`a realizzato e implementante un design pattern architetturale Model View Controller, per quanto Unity ne permetta un'implementazione limitata.\\
I design pattern sono strumenti che aiutano a risolvere un certo tipo di problema comune. Quindi, \`e necesseria la presenza di un problema per applicare un design pattern che lo risolva.\\
Bisogna sottolineare il fatto che Unity si basa pesantemente attorno alle componenti o ai pi\`u noti "GameObject", ovvero gli oggetti di gioco e non c'\`e modo di aggirare questa cosa.\\\\
Segue ora una descrizione di come \`e stato progettato il configuratore comprensivo delle funzionalit\`a di base offerte da un configuratore gi\`a realizzato e delle parti da me costruite.\\


\begin{figure}[H]
	\centering
	\includegraphics[width=1.1\textwidth]{\docsImg Class.png}
	\caption{Diagramma delle classi generico}
	\label{fig:Diagramma delle classi}
\end{figure}
\newpage

In figura \ref{fig:Diagramma delle classi} si pu\`o notare come sia stata organizzata l'architettura dell'applicazione sulla base di ci\`o che era gi\`a stato realizzato. In particolare, necessita una spiegazione l'etimologia dei colori del diagramma:

\begin{itemize}
	\item \textbf{Giallo}: le classi colorate in giallo rappresentano classi gi\`a presenti e realizzate dai colleghi del reparto tecnico a cui non sono state apportate modifiche.
	\item \textbf{Azzurro}: Le classi colorate di azzurro rappresentano le classi gi\`a implementate a cui per\`o \`e stata applicata una modifica non banale.
	\item \textbf{Verde}: in verde le classi create da zero.
\end{itemize}

Come \`e facile notare dal diagramma, il modello di gestione dei prodotti del configuratore era gi\`a implementato in una sorta di MVC. Il mio compito \`e stato quello di adattare il codice gi\`a sviluppato perch\`e si prendesse carico dell'inserimento e della gestione di un nuovo tipo di contenuto. \\
Inoltre, il mio compito principale riguardava la gestione dell'avatar all'interno dell'applicazione e la gestione delle gesture.

\paragraph{Architettura generale}
Da subito sono state definite quelle che avrebbero dovuto essere le entit\`a principali all'interno dell'applicazione, ovvero:

\begin{itemize}
	\item \textbf{Product}: Classe rappresentante il modello dati di un prodotto, avente il compito di memorizzare tutte le informazioni relative a un parquet, quali: nome, linea, categoria, finitura, codice, descrizione, essenza, scelta, superficie e dimensioni. Inoltre contiene il nome del padre del prodotto e uno sprite di dimensioni 300x300(px) da usare come icona.
	
	\item \textbf{ProductController}: Questa classe si occupa di istanziare l'oggetto 3D rappresentante il prodotto vero e proprio una volta che un prodotto viene selezionato. Il modello 3D viene caricato e istanziato runtime dalle risorse disponibili in base al nome dell'oggetto scelto, che quindi dovr\`a essere univoco tra i vari prodotti e contenere la stringa "\_3d" in coda.
	
	\item \textbf{HierarchyElement}: Classe che si occupa di gestire genitore e figli del prodotto preso in considerazione.
	
	\item \textbf{DataController}: Questa \`e la classe centrale su cui si basa tutto il funzionamento del configuratore. Il compito di questa classe \`e quello di gestire la gerarchia completa di prodotti, permettendo di impostare il nome e l'icona delle varie categorie, e di impostare i genitori e le icone di ogni prodotto. Tutto questo pu\`o essere gestito come plugin di Unity semplicemente attaccando lo script a un GameObject vuoto.
	
	\item \textbf{AvatarPositionController}: Classe principale di gestione e controllo dell'avatar. Qui viene gestito il posizionamento dell'avatar: all'avviod ell'applicazione l'avatar viene posizionato sopra il tag ad una grandezza fissata, successivamente, una volta terminata la presentazione iniziale, l'avatar viene spostato e fissato a schermo in una posizione laterale e non troppo ingombrante. Quando l'avatar \`e fissato a schermo ha una scala posta a zero, mentre viene ingrandito una volta richiamato tramite apposito pulsante. Questo script si occupa anche di gestire la posizione e l'apparizione del ventaglio iniziale per poi invocare il metodo dedicato alla presentazione vera e propria dell'avatar.
	
	\item \textbf{StartController}: E' la classe che si occupa di gestire la presentazione iniziale dell'avatar. Qui vengono caricati i file audio e temporizzati con l'inizio delle animazioni. La classe si occupa di gestire sia l'avviosia il termine (anche richiesto dall'utente) dell'applciazione.
	
	\item \textbf{SpeakerAndAnimationController}: Classe realizzata con lo scopo di gestire l'avatar in modo da fargli presentare le categorie tramite animazioni e file audio. Non era conosciuto a priori il numero di animazioni che si sarebbero dovute implementare per cui questa classe doveva essere progettata in modo da gestire un numero indefinito di animazioni e file audio.
	
	\item \textbf{PinchToScale}: Questa classe non si occupa di riconoscere la gesture, compito dedicato a una classe sviluppata da terzi, ma si occupa di definire il comportamento quando viene rilevata una particolare gesture sul modello 3D del prodotto.
	
	\item \textbf{SwipeManager}: Questa classe, come la precedente, non \`e un riconoscitore di gesture ma un gestore che si occupa di definirne il comportamento. Lo SwipeManager deve aprire e chiudere i men\`u in pase al tipo di swipe effettuato.
	
	\item \textbf{ScreenshotManager}: Si occupa di gestire la cattura e il salvataggio della schermata visualizzata dul display. Lo script si affita all'utilizzo di classi dedicate sviluppate da terzi e ha il compito di gestire cosa deve essere visualizzato nello screenshot.
	
	\item \textbf{CoraMailBuilder}: E' lo script che si occupa della creazioen della mail di richiesta preventivo su un determinato prodotto
	
	\item \textbf{LevelBehaviour}: Questa classe si occupa di popolare il men\`u inferiore dell'applicazione, creando i pulsanti per ogni categoria e i pulsanti relativi ai prodotti.
\end{itemize}

Questi sono gli script principali utilizzati nella realizzazione del progetto. Come gi\`a detto, sono stati creati altri script pi\`u dedicati e di rifinitura, la cui spiegazione in dettaglio non far\`a parte di questo documento per non appesentirne la lettura.\\\\

\paragraph{Layout e GUI}
Per quanto riguarda la GUI dell'applicazione, essa \`e stata progettata da terzi per conto di Cor\`a Divisione Parquet e mi \`e stata inviata tramite un file PSD contenente le grafiche da utilizzare e il layout a cui adeguarsi.\\
Il layout \`e stato scelto sulla base dei configuratori precedentemente utilizzati ed \`e stato adattato per il progetto specifico.

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{\docsImg layout1.jpg}}
	\caption{Layout con menu' info aperto}
	\label{fig:Layout con menu info aperto}
\end{figure}

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{\docsImg layout2.jpg}}
	\caption{Layout con menu inferiore aperto}
	\label{fig:Layout con menu inferiore aperto}
\end{figure}
\newpage
Di seguito vengono descritti i componenti principali della GUI.

\begin{itemize}
	\item \textbf{Logo}: il logo \`e un pulsante cliccabile che apre il men\`u dei Credits nel centro dello schermo;
	\item \textbf{Men\`u inferiore}: contiene la lista delle categorie, con eventualmente la relativa icona, e la lista dei prodotti come figli della propria categoria madre. Il men\`u \`e composto da una "breadcumb" navigabile, e da una sequenza di bottoni assegnati ognuno ad una categoria, e nei livelli pi\`u profondi ai prodotti.
	\item \textbf{Pannello Info}: \`e un pannello laterale che compare dopo la pressione del pilsante "i". Il pulsante in questione diventa visibile solo quando un prodotto \`e selezionato e permette di aprire la sezione relativa alla descrizione del prodotto. Il pannello si compone anche di un pulsante per l'acquisizione di screenshot e un pulsante per la richiesta di preventivo del prodotto visualizzato.
	\item \textbf{Pulsante animazione}: \`e un pulsante a forma di fumetto situato nella parte a est dello schermo, e diventa visibile ogni volta che l'avatar ha qualcosa da dire. Nello specifico, compare quando viene selezionata una categoria interna alle "linee di prodotto", e scompare negli altri casi. La comparsa \`e seguita da un'animazione di notifica per richiamare l'attenzione dell'utente. Una volta rpemuto il pulsante, compare l'avatar nella parte ovest dello schermo iniziando l'animazione dedicata.
	\item \textbf{Scope}: mirino posizionato al centro dello schermo e utilizzato per fornire brevi istruzioni all'utente su cosa fare e dare la possibilit\`a all'utente di scaricare il tag, oltre al fatto di eseguire la sua funzionalit\`a principale di supporto per mirare il tag.
\end{itemize}

L'apertura del men\`u, dei credits e del pannello laterale non \`e mutualmente esclusiva, in quanto tutte e tre le componenti possono essere visibili in stato aperto contemporaneamente senza interferire tra di loro.\\


In questo capitolo ho avuto voce, in quanto ho potuto esprimere il mio dissenso su alcune scelte relative all'usabilit\`a dell'applicazione mantenedo un certo tipo di layout. Queste osservazioni e richieste di modifica della grafica sono state concordate prima con Project manager e successivamente con il cliente. Le modifiche osservate e accolte sono state:

\begin{itemize}
	\item Grandezza del pannello delle informazioni laterali. Essendo troppo piccolo risulatava inutilizzabile da smartphone.
	\item Stile dell'icona dell'applicazione che risultava poco leggibile.
	\item Posizione del pulsante animazione. Inizialmente posto nella parte superiore dello schermo, risultava difficile da raggiungere con un'impugnatura standard del device.
\end{itemize}

Inoltre, ho proposto l'utilizzo di un tag di grandezza A3, al posto del foglio A4 utilizzato per ottenere un miglior risultato di agganciamento del tag e di tracking. Questa richiesta non \`e stata accolta in quanto si presuppone la stampa domestica del tag in assenza di possibilit\`a di stampare fogli A3.\\


\paragraph{Animator Controller}
Gli Animator Controller sono i gestori delle animazioni di un GameObject in Unity. Generalmente, ogni oggetto chesi vuole animare ha attaccato un Animator con associato un Animator Controller che ne definisce il comportamento. In questo progetto, tali componenti hanno avuto un ruolo fondamentale, per cui \`e stata necessaria un'attenta progettazione di queste componenti.\\
In questo paragrafo verranno tralasciate le spiegazioni degli Animation Controller banali.\\

\begin{itemize}
	\item \textbf{Info Panel Controller}: controller dedicato al pannello laterale per gestire le animazioni entrata, uscita e di oscurazione del pulsante "i". Esempio utile per capire come ogni oggetto della GUI \`e stato gestito in modo simile. Ogni animazione viene fatta partire al cambio di stato di un valore booleano oppure all'azionamento di un particolare trigger.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\textwidth]{\docsImg InfoPanelController.png}
		\caption{Animator Controller del pannello Info laterale}
		\label{fig:Animator Controller del pannello Info laterale}
	\end{figure}
	
	Nel dettaglio: INFO\_DEF nasconde sia pannello che pulsante, INFO\_HIDE mostra il pulsante "i", INFO\_SHOW apre il pannello su schermo, INFO\_SHOT, rimuove gli elementi della GUI indesiderati per l'esecuzione di uno screenshot.
	
	\item \textbf{Avatar Speaker Controller}: dedicato alla gestione della presentazione iniziale da parte dell'avatar e alle animazioni relative alla spiegazione delle categorie.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\textwidth]{\docsImg AvatarSpeakerController.png}
		\caption{Animator Controller dell'avatar}
		\label{fig:Animator Controller dell'avatar}
	\end{figure}
	
	Nel dettaglio: IDLE \`e lo stato iniziale, a cui l'avatar ritorna alla fine di ogni presentazione. Lo stato PRESENTATION \`e un particolare stato in cui l'animator viene portato nel momento in cui si vuole avviare la presentazione iniziale. Questo stato termina poi con il passaggio a END\_PRESENTATION che \`e uno stato necessario per effettuare alcuni controlli da codice, come controllare che la presentazione sia terminata. Lo stesso viene fatto con le n categorie di prodotti di cui si ha la presentazione.\\ Questo animator poteva essere implementato in modo pi\`u efficiente caricando l'animazione da fare partire di volta in volta in base a una stringa passata. Avendo tempo limitato si \`e preferito procedere per una strada di facile implementazione come questa.
\end{itemize}






\subsubsection{Implementazione}
L'attivit\`a di implementazione e di codifica si \`e svolta secondo quanto previsto dalla metodologia Agile. Le fasi di codifica non son avvenute in un unico round, ma in brevi e frequenti blocchi di tempo. Per prima cosa, sono state implementate le parti principali del sistema, cio\`e le parti che quasi sicuramente non avrebbero avuto modifiche nelle successive iterazioni.\\

Si \`e proceduto, in primo luogo, con l'adattamento di quanto disponibile nel configuratore base. In particolare \`e stata creata una classe Product in grado di contenere tutte le informazioni necessarie per ogni prodotto.\\

\paragraph{Pinch-To-Scale}
E' stata richiesta la possibilit\`a di espandere il parquet mostrato in realt\`a aumentata direttamente runtime tramite l'applicazione di una gesture dedicata.\\
Bisogna premettere che le texture dei parquet sono state recapitate simulandone la grandezza reale per cui, data anche l'irregolarit\`a di alcuni parquet, era difficile fare il tiling (ripetizione della texture su uno o pi\`uassi) della texture.\\
Su suggerimento del CTO si \`e deciso di procedere mantenedo la dimensione reale della texture, senza tiling, e applicando una maschera ridimensionabile all'oggetto in modo tale da visualizzarne solo una parte. La realizzazioen \`e stata affidata completamente a me.\\
E' stata realizzata una maschera a forma di cornice, unendo pi\`u oggetti tridimensionali prefabbricati. A tale maschera \`e stato poi applicato un particolare shader in grado di rimuovere il rendering delle parti di texture coperte dalla maschera.\\
Di seguito \`e illustrata la codifica relativa allo script PinchToScale.\\
\noindent
\textbf{1. PinchToScale.cs}

\begin{lstlisting}

public class PinchToScale : MonoBehaviour
{
public Vector3 scaleWeights = Vector3.one;
public float minScaleAmount = 0.4f;
public float maxScaleAmount = 4.0f;
public float sensitivity = 0.3f;		// augment for a bigger scaling
public float smoothingSpeed = 12.0f;    // set to 0 to disable smoothing
public GameObject mask;

private float idealScaleAmount = 0.4f;
private float scaleAmount = 0.4f;
private Vector3 baseScale = Vector3.one;

public float ScaleAmount
{
	get { return scaleAmount; }
	
	set 
	{ 
		value = Mathf.Clamp( value, minScaleAmount, maxScaleAmount );	//check if the value is between limits
		
		if( value != scaleAmount )
		{
			scaleAmount = value;
			
			Vector3 s = scaleAmount * baseScale;
			s.x *= scaleWeights.x;
			s.y *= scaleWeights.y;
			s.z *= scaleWeights.z;
			
			mask.transform.localScale = s;			//resize the mask scale
		}
	}
}

public float IdealScaleAmount
{
	get { return idealScaleAmount; }
	set { idealScaleAmount = Mathf.Clamp( value, minScaleAmount, maxScaleAmount ); }
}

void Start()
{
	baseScale = transform.localScale;
	IdealScaleAmount = ScaleAmount;
}

void Update()
{
	if (smoothingSpeed > 0) {
		ScaleAmount = Mathf.Lerp (ScaleAmount, IdealScaleAmount, Time.deltaTime * smoothingSpeed);
	} else {
	ScaleAmount = IdealScaleAmount;
}
}

void OnPinch( PinchGesture gesture )
{  
	IdealScaleAmount += sensitivity * gesture.Delta.Centimeters();
} 
\end{lstlisting}

Il codice, all'avvio dello script, memorizza la scala locale dell'oggetto, e imposta il valore di scaling ideale allo scaling di base. Ad ogni frame viene aggiornato, internamente al metodo Update, lo scaling attuale, sia nel caso sia presente un effetto di smooth sia altrimenti. Quando viene catturata una gesture di Pinch, ne viene presa l'ampiezza in centimetri e moltiplicata per la sensibilit\`a che gli si vuole dare allo scaling rispetto alla gesture. Questo valore calcolato viene memorizzato in IdealScaleAmount che nel successivo Update sar\`a memorizzato come nuovo valore di ScaleAmount. ScaleAmount ogni volta che viene modificato si occupa di applicare lo scaling impostato alla maschera passata come parametro da Unity.\\\\


\paragraph{Inserimento prodotti}
Successivamente ho proceduto con l'inserimento dei primi 20 prodotti, in quanto il modello e la gestione delle categorie e dei prodotti era gi\`a implementata. Per ogni prodotto, prima si \`e dovuta importare negli assets la relativa texture e icona, poi, dopo aver attaccato uno script Product al prodotto comprensivo del modello 3D, questo veniva processato in uno script (VariationMaker.cs) che creava 2 oggetti: un GameObject contenente le informazioni del prodotto da utilizzare nello script di gestione dei dati (DataController.cs) e un GameObject con il modello 3D.\\

\paragraph{Gestione dell'avatar}
Come gi\`a accennato, il grosso del lavoro consistava nell'implementazione di un avatar all'interno dell'applicazione. Per prima cosa \`e stato gestita la presentazione iniziale composta da 4 file di animazione e 4 file audio. E' stata usata la tecnica del lip sync per ottenere un effetto realistico. Di ci\`o se ne \`e occupato lo StartController sviluppato appositamente.\\
Lo StartController \`e stato implementato utilizzando il design pattern Singleton in quanto era necessario avere al pi\`u un'istanza della classe.\\

	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.4\textwidth]{\docsImg ava.jpg}
		\caption{Presentazione iniziale}
		\label{fig:Presentazione iniziale}
	\end{figure}


All'avvio dello StartController vengono caricati in memoria gli audio file relativi alla presentazione. Durante ogni ciclo di Update, invece, viene controllato lo stato dell'animazione corrente e il numero contenuto all'interno di un particolare contatore. In questo modo \`e possibile eseguire nell'ordine corretto i vari pezzi ottenendo, cosi, l'animazione completa, senza che venga ciclata pi\`u volte essendo che il contatore procede verso un'unica direzione incrementale e viene ripristinato solo quando si vuole riavviare la presentazione.\\

Di seguito viene mostrata la codifica del metodo Awake() che si occupa del caricamento dei file audio.
\\\\
\textbf{2. StartController.cs - Metodo Awake()}
\begin{lstlisting}
	void Awake() {
		_instance = this;
		pt1 = (AudioClip)Resources.Load ("Speakeraggio/01_Presentazione1", typeof(AudioClip));
		pt2 = (AudioClip)Resources.Load ("Speakeraggio/02_Presentazione2", typeof(AudioClip));
		pt3 = (AudioClip)Resources.Load ("Speakeraggio/03_Presentazione3", typeof(AudioClip));
		pt4 = (AudioClip)Resources.Load ("Speakeraggio/04_Presentazione4", typeof(AudioClip));
	}
\end{lstlisting}

E il metodo Update() che si occupa della gestione delle animazioni e della sincronizzazione con i file audio. Inoltre si pu\`o notare come venga reso disponibile un pulsante "Skip" per saltare la presentazione.
\\\\
\textbf{3. StartController.cs - Metodo Update()}
\begin{lstlisting}
	void Update(){
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("01_Presentazione1") && startLock == 1) {
			presentationAudio.clip = pt1;
			presentationAudio.Play();
			skipButton.SetActive(true);
			skipButton.GetComponent<Animator> ().SetBool ("Show", true);
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("02_Presentazione2") && startLock == 2) {
			presentationAudio.clip = pt2;
			presentationAudio.Play();
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("03_Presentazione3") && startLock == 3) {
			presentationAudio.clip = pt3;
			presentationAudio.Play();
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("04_Presentazione4") && startLock == 4) {
			presentationAudio.clip = pt4;
			presentationAudio.Play();
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("EndPresentation") && startLock == 5) {
			EndPresentation ();
			startLock = 1;
		}
	
	}
\end{lstlisting}

Il passo di implementazione successivo \`e stato la gestione della posizione dell'avatar. All'inizio doveva risultare agganciato al tag per poi spostarsi e rimanere agganciato alla parte ovest dello schermo, comparendo solo su richiesta.\\
Questo script \`e quello che pi\`u ha usufruito della metofologia Agile, e in particolare quello che ha subito pi\`u incrementi nelle varie iterazioni.\\
Questo perch\`e il cliente, non essendo un esperto di realt\`a aumentata e, soprattutto di applicazioni Android, non aveva un'idea precisa di come e dove dovesse apparire l'avatar. Per cui sono state richieste numerose prove per ottenere il risultato che pi\`u rendesse felice il cliente.\\
In iterazioni intermedie era sta prevista persino un'interessante funzionalit\`a per cui il device calcolava l'altezza rispetto al tag e modificava la grandezza dell'avatar per una visione "da alzati" e una "da seduti". Questa funzionalit\`a da me realizzata \`e piaciuta molto al team di sviluppo ma \`e stata bocciata dal cliente finale che, alla fine, \`e stato convinto del Project Manager della soluzione ottimale con avatar di grandezza fissa.\\
Questo script \`e fondamentale perch\`e gestisce le animazioni dei vari componenti che agiscono nella presentazione iniziale e le sincronizza per ottenere il miglior effetto visivo.\\\\

L'ultimo script realizzato per il controllo dell'avatar \`e lo script che si occupa di gestire le presentazioni delle varie categorie, chiamato SpeakerAndAnimationController. Nel dettaglio, il pulsante di una categoria invoca, alla pressione, un metodo chiamato SetPresentation(string) che si occupa di caricare in memoria l'audio corrispondente effettuando una ricerca per nome negli assets. Nel caso la ricerca termini correttamente viene mostrato il pulsante animazione (pulsante a forma di fumetto), altrimenti viene nascosto, se gi\`a visibile, o non mostrato.\\
Alla pressione del pulsante animazione viene invocato un metodo dedicato allo start e allo stop della presentazione. In particolare, se esiste gi\`a un'audio e un'animazione in esecuzione da parte dell'avatar, e viene premuto tale pulsante, l'animazione viene fermata. Se invece  non \`e presente alcuna presentazione in esecuzione, viene fatto partire l'audio in memoria con la relativa animazione, facendo comparire l'avatar con un effetto di scaling.\\
E' utile osservare il funzionamento del metodo Update() per capire come avviene la sincronizzazione tra audio e animazione.
\\\\
\textbf{4. SpeakerAndAnimationController.cs - Metodo Update()}
\begin{lstlisting}
void Update(){
	if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("EndSpeech")) {
		StartCoroutine(scaleIn( new Vector3 (100f, 100f, 100f), new Vector3(0f,0f,0f), 1.5f));
		hasAudioBeenPlayed = false;
		instance.resetAnimation (active);
	}
	if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("Idle") && active != "") {
		AudioClip audio = (AudioClip)Resources.Load ("Speakeraggio/" + active, typeof(AudioClip));
		activeAudio.clip = audio;
	}
	if (!hasAudioBeenPlayed && !string.IsNullOrEmpty(active) && avatarController.GetCurrentAnimatorStateInfo (0).IsName (active)) {
		hasAudioBeenPlayed = true;
		activeAudio.Play ();
	}
}
\end{lstlisting}

Come si pu\`o notare, viene fatto un controllo sullo stato in esecuzione dell'animator controller. In particolare, se ci si trova in uno stato di fine presentazione, viene data la possibilit\`a di far partire un nuovo audio e viene nascosto l'avatar.
Se l'avatar si trova nello stato iniziale, viene caricato l'audio corrente, mentre se l'animazione relativa all'audio \`e attiva e l'audio pu\`o essere eseguito viene effettuato un play, che avviene in modo sincronizzato con l'animazione.\\

\paragraph{Gestione della GUI}
La GUI \`e l'aspetto del progetto che pi\`u ha subito modifiche. Inizialmente, per trovare la resa grafica migliore a livello estetico e, successivamente, per garantire il pi\`u alto livello possibile di usabilit\`a. Il problema principale \`e stato identificare il contesto di utilizzo dell'applicazione e decidere se ottimizzare l'interfaccia per smartphone o tablet, in quanto la creazioen di due interfacce ad-hoc avrebbe avuto un costo aggiuntivo per il cliente. Si \`e deciso di ottimizzare l'app per smartphone, in quanto pi\`u reperibile. Lo sviluppo della GUI \`e avvenuto seguendo come linea guida un file PSD contenente le varie schermate e da cui era possibile prendere le grafiche (icone, pulsanti, etc.)

\paragraph{Implementazione del tutorial}
Come ultimo passo di implementazione, ho proceduto con la creazione del tutorial, prendendo le grafiche da una sezione del file PSD dedicato e modificando del codice gi\`a creato per configuratori precedentemente realizzati. Il tutorial \`e stato pensato in modo tale da procedere con l'avanzamento grazie a un tap sullo schermo ed \`e stata prevista una funzionalit\`a per saltare il tutorial ed andare direttamente alla parte del configuratore.

\subsubsection{Verifica e validazione}
Contestualmente all'applicazione sviluppata, i principali test svolti hanno riguardato il corretto funzionamento di tutte le funzionalit\`a rese disponibili. L'attivit\`a di verifica e validazione \`e stata svolta quasi totalmente da alcuni colleghi del team tecnico e dal Project Manager, che hanno potuto valutare, durante tutto lo svolgimento del progetto, la correttezza dei componenti da me sviluppati.\\
I test avvenuti hanno avuto sempre esito positivo riguardo il corretto funzionamento dei componenti e hanno portato alla luce piccoli bug prontamente corretti.\\
Oltre ai test interni, ad ogni iterazione veniva fornita l'app a un responsabile esterno dell'azienda Cor\`a Divisione Parquet, che aveva il compito di effettuare ulteriori test sulla qualit\`a del prodotto e doveva verificare la corrispondenza di funzionalit\`a tra le aspettative e l'applicazione reale.\\
I feedback da parte del cliente sono sempre stati positivi su quanto sviluppato, tranne per il lavoro svolto sull'avatar che, almeno inizialmente, non corrispondeva aa quanto si aspettavano. Con successive iterazioni sono riuscito riuscito ad ottenere un effetto ottimale dell'avatar che portasse soddisfazione al cliente.\\
I device utilizzati per il testing dell'applicazione sono stati:

\begin{itemize}
	\item Google Nexus 5 (Android);
	\item Samsung Note 4 (Android):
	\item Samsung Galaxy S3 (Android);
\end{itemize}

Per quanto riguarda, invece, il testing dell'app durante l'attivit\`a di implementazione, \`e stato usato un plugin di Vuforia per Unity che permette l'utilizzo di una webcam per simulare la fotocamera dei device.

\subsection{Livello di completezza raggiunto}
In definitiva, e' stata realizzata un'applicazione configuratore in realt\`a aumentata dedicata alla visualizzazione di parquet in legno in un contesto domestico. L'applicazione si compone di un men\`u inferiore dedicato alla ricerca e selezione dei prodotti in base alla loro categoria o in base al loro colore. Un prodotto selezionato viene reso visibile agganciato al tag e viene reso disponibile un men\`u laterale in cui e' possibile leggere le informazioni del prodotto, scattare uno screenshot e richiedere un preventivo relativo al parquet selezionato.\\\\

Alla fine del tempo di stage si pu\`o stimare un completamento del progetto quasi totalitario, in quanto l'ultima richiesta da parte del cliente prima della pubblicazione dell'app \`e stata quella di implementare il follow di occhi e testa dell'avatar rispetto alla telecamera. Questo ultimo aspetto \`e stato sviluppato interamente da un collega del reparto tecnico dopo la conclusione del mio stage.\\