\section{Resoconto dello stage}
\subsection{Pianificazione di progetto}
\subsubsection{Descrizione generale}
Come gia' detto in precedenza, lo stage e' stato suddiviso in due parti: la prima orientata alla formazione su strumenti e tecnologie e la seconda parte orientata alla realizzazione di progetti destinati ai clienti esterni. Come tale, l’attività di formazione e' stata opportunamente orientata all’apprendimento, da parte mia, delle meccaniche e delle norme vigenti internamente per lo sviluppo di tali progetti, oltre che alla normale parte di formazione tecnica prevista per portare a termine in maniera opportuna le attività dei progetti stessi.
L’obiettivo finale dello stage e' stato quindi quello di inserirmi come parte integrante del team di sviluppo per i progetti esterni, attribuendomi responsabilità e compiti adeguati al mio ruolo e orientati alle attività di produzione, testing e delivery di app mobile di Realtà Aumentata; la valutazione finale da parte del tutor aziendale e' stata quindi effettuata sulla base sia della qualità sia della quantità delle attività portate a termine nella fase produttiva finale, oltre che alla capacità di lavorare correttamente in squadra con l’obiettivo comune di consegnare un prodotto finale nei tempi e nelle modalità stabilite.
\\\\
Nel periodo antecedente l'inizio dello stage, insieme al tutor aziendale, sono state concordate le attivita' principali che avrei dovuto svolgere durante il periodo seguente della durata di 2 mesi. Nella descrizione delle attivita', riportata nella sezione successiva, e' stata fornita una descrizione molto generica per quanto riguarda il progetto principale che avrei dovuto seguire in quanto non era ancora chiaro a priori se ci sarebbe stata o meno la possibilita' di seguire un progetto commissionato dall'esterno.
\\\\
La dislocazione temporale delle attivita e' stata rappresentata graficamente in un Diagramma di Gantt che mi ha aiutato ad avere sempre una visione accurata sullo stato del mio stage, in particolare su eventuali ritardi. Rispetto al diagramma concordato nel piano di lavoro, il mio stage e' partito dopo 2 giorni rispetto a quanto concordato a causa di un'indisponibilita' del tutor aziendale, per cui e' stata rifatta la pianificazione tenendo conto di questo ritardo.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg Gantt.png}
	\caption{Diagramma di Gantt delle attivita'}
	\label{fig:Diagramma di Gantt delle attivita'}
\end{figure}

Il Diagramma di Gantt riportato in figura \ref{fig:Diagramma di Gantt delle attivita'} mostra piuttosto fedelmente quanto svolto durante il periodo in azienda ed eventuali anticipi sulla tabella di marcia sono stati riempiti con approfondimenti sulle tecnologie e sessioni di ricerca e sviluppo su visori Google Cardboard. Non ci sono stati, invece, ritardi su quanto preventivato.

\subsubsection{Dettaglio delle attivita'}
Di seguito vengono elencate in dettaglio le attivita' svolte durante il periodo di stage svolto presso l'azienda ospitante Experenti. Un approfondimento per le principali. 

\begin{enumerate}
	\item	Formazione sulle tecnologie utilizzate internamente per lo sviluppo, quali framework e SDK. In particolare:
	
	\begin{enumerate}	
		\item	Ambiente di sviluppo (IDE) utilizzato (Unity3D) e fondamenti dei sistemi operativi mobile (Android e iOS); 
		\item	Formazione sulle librerie utilizzate internamente per l’elaborazione delle immagini per la realtà aumentata e per il successivo riconoscimento delle stesse in ambiente mobile; 
		\item	Formazione sull’app Experenti: nascita del progetto, funzionamento attuale, obiettivi di sviluppo. Formazione sulle procedure standard applicate internamente.	
	\end{enumerate}
	
	\item	Realizzazione di un esempio di contenuto in Realtà Aumentata a tema libero. Questo contenuto, il cui sviluppo è stato necessario alla comprensione del flusso di lavoro interno e all'individuazione di determinate problematiche relative all’ambito AR mobile, ha particolari caratteristiche, quali animazioni e/o movimenti di parti specifiche, un certo grado di interattività e prevede parti semplici di grafica GUI (su schermo, in modalità HUD). E' stata richiesta, inoltre, l’individuazione di un tag adatto al riconoscimento dalle fotocamere mobile, possibilmente legato alla tematica che e' stata sviluppata.
	\item	Analisi di casi di studio e app varie già realizzate internamente. Focus particolare sui progetti base già realizzati e sulla loro struttura: progetto base demo, progetto base visore AR, progetto base configuratore. In questa fase e' avvenuta la formazione sul flusso di lavoro standard interno all’azienda e sul normale iter di un progetto commissionato da un cliente, dalla ricezione dei materiali fino alla fase di distribuzione (sia essa una distribuzione ad hoc o una distribuzione pubblica tramite Store mobile) ed e' iniziato l'affiancamento al Project Manager nelle fasi di accettazione materiali. 
	\item	Realizzazione di un’app demo completa. Per app demo si intende un’app a distribuzione solitamente ad hoc (non pubblicata sugli Store) resa disponibile dall’azienda per i propri clienti o reseller, comprendente un numero solitamente limitato di contenuti semplici (3D o video) fruibili dall’utente in realtà aumentata attraverso l’uso di un tag fornito dal cliente stesso. L’app possiede, inoltre, una GUI minimale ma personalizzata con il logo del cliente stesso, nonchè un’icona e una splashscreen anch’esse personalizzate allo stesso modo. Richiesto l'affiancamento al Project Manager fin dalla fase iniziale di ricezione materiali, e prosecuzione poi in autonomia nella fase di sviluppo fino alla fase di rilascio e consegna (previa verifica del risultato prodotto da parte del Tutor Aziendale). L’entità dell’app demo e' stata stabilita dal Project Manager aziendale alcuni giorni prima dell’inizio di questa fase e si e' data preferenza, alla produzione di una demo per un cliente esterno. 
	\item	Inserimento effettivo nel team di sviluppo per i progetti esterni. In questa fase, inizia l'affiancamento al team di sviluppo per i progetti commissionati dai clienti esterni; e' iniziato quindi il coordinamento dal Project Manager aziendale nell’assegnazione di task appositi comprendenti le fasi di sviluppo e testing di intere app semplici o parti di app complesse; si e' preferito assegnare la realizzazione di almeno un’app semplice nella sua interezza commissionata da un cliente esterno. L’assegnazione delle attività e' stato effettuato attraverso il sistema di ticketing utilizzato internamente all’azienda, attraverso il quale e' stato anche richiesto di rendicontare le proprie attività in termini di tempo utilizzato per ciascuna di esse, mentre l’assegnazione dei singoli task e' stata effettuato dal Project Manager aziendale in collaborazione con il tutor aziendale. E' stato valutato positivamente in questa fase la capacità di attenersi alle tempistiche date e il livello di dettaglio fornito nella successiva rendicontazione delle ore, oltre ovviamente alla qualità intrinseca del risultato prodotto. 
\end{enumerate}

\begin{center}
	
	\begin{longtable}{c| p{0.7\textwidth}| c}

		\textbf{Sezione} & \textbf{Descrizione} & \textbf{Ore di lavoro}\\ \cline{1-3}
		\phantomsection
		1.1&  Formazione su ambienti di sviluppo&  40 \\
				\phantomsection
		1.2&  Formazione su librerie utilizzate&  28 \\
				\phantomsection
		1.3&  Formazione sull’app Experenti&  12 \\
				\phantomsection
		2&  Realizzazione di un contenuto di realtà aumentata a tema libero&   56\\	
				\phantomsection
		3&  Analisi su progetti già realizzati internamente e formazione su flusso di lavoro interno&   40\\
				\phantomsection	
		4&  Realizzazione di un’app demo completa&   24\\
				\phantomsection					
		5&  Inserimento nel team di sviluppo e realizzazione di un’app nella sua interezza&   120\\ \cline{1-3}
				\phantomsection
		  & \textbf{TOTALE} & \textbf{320}  \\\\
		  		\caption{Tabella relativa alle ore dedicate per ciascuna attivita'}\\
	\end{longtable}
		
\end{center}

\subsection{Studio delle tecnologie e strumenti}
In questa sezione, vengono spiegate le attivita' di apprendimento svolte per imparare l'utilizzo delle nuove tecnologie e degli strumenti usati.
\subsubsection{Unity 3D}
Unity, come gia' detto in precedenza e' un sistema cross-platform per lo sviluppo di giochi composto da un game engine e da un IDE integrato. Unity viene usato internamente all'azienda per lo sviluppo di app mobile distribuite su Android e iOS.
\\
Unity nel suo sito fornisce un grosso supporto agli sviluppatori fornendo una documentazione completa e una sezione ben fornita di tutorial testuali e video suddivisi per categoria.\\
Inizialmente, ho dovuto seguire una parte di video tutorial riguardanti l'interfaccia di Unity, lo scripting, la gestione della fisica, animazioni e gestione della GUI. Questa primo periodo si e' svolto integrando, oltre alla visione, anche la prova diretta sull'editor in modo da assimilare meglio i concetti appresi.\\
Nel caso in cui volessi approfondire un argomento oppure non lo ritenessi abbastanza chiaro, avevo sempre la possibilita' di ottenere una spiegazione da parte del tutor aziendale, il quale si e' dimostrato sempre molto disponibile anche nel ripetere piu' volte lo stesso concetto.\\
In questa parte di formazione, dopo aver seguito e implementato un tutorial riguardante l'animazione di un avatar, di mia iniziativa, ho effettuato il porting dell'applicazione su Android gestendo touch e multi-touch sullo schermo e impostando i movimenti dell'avatar basandoli sull'acelerometro del dispositivo mobile.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg tutorial.jpg}
	\caption{Implementazione in Unity del tutorial riguardante l'animazione di un avatar 3D di cui successivamente e' stato eseguito il porting su Android}
	\label{fig:tutorial riguardante l'animazione di un avatar 3D}
\end{figure}
 
\subsubsection{Vuforia SDK}
Terminata la parte di formazione su Unity 3D, e' iniziata la parte di preparazione relativa a Vuforia SDK, l'SDK utilizzato dall'azienda per l'implementazione della realta' aumentata. Nello specifico, il team tecnico si e' occupato di spiegarmi come funziona l'SDK, e come funziona nello specifico il plugin di Unity, grazie alla quale è possibile operare all’interno di un unico ambiente di lavoro. Le attivita' principali svolte in questo lasso di tempo sono state l'implementazione di modelli 3D e di video associati ai tag, e lo studio sul riconoscimento e la creazione di tag ottimali.

\subsubsection{Photon Unity Networking}
Photon Unity Networking (PUN) e' un framework di Unity per l'implementazione del multiplayer realtime neigiochi o nelle applicazioni sviluppate. Le applicazioni svilupapte con Photon vengono eseguite su un server cloud proprietario. Quindi, le operazioni di scaling e di service hosting sonogestite interamente da PUN, permettendo allo sviluppatore di concentrarsi puramente sulla costruzione dell'applicazione. Tutti i prodotti Photon Cloud sono basati su un'architettura client-to-server, che e' la soluzione ottimale per il gaming onlire rispetto a una connessione peer-to-peer.\\
Photon e' un package scaricabile dall'Asset Store (negozio di Unity online in cui comprare o scaricare gratuitamente asset come script, modelli 3D e 2D, etc.), e nella sua versione gratuita prevede l'accesso concorrente fino a 20 utenti sulla stessa stanza. \\\\
Di seguito vengono riportati esempi di codice per mostrare la semplicita' di utilizzo del framework.\\
\begin{itemize}
	\item \textbf{Connessione al server}: La connessione al server si basa sul passaggio di una stringa contenente la versione dell'applciazione. Puo' essere usata per dividere gruppi di client.
\begin{lstlisting}
PhotonNetwork.ConnectUsingSettings("1.0");
\end{lstlisting}

	\item \textbf{Accesso a una stanza}: Per prendere parte a una partita esistente basta la seguente riga di codice specificando il nome della stanza in cui si vuole entrare.
\begin{lstlisting}
PhotonNetwork.JoinRoom("RoomName");
\end{lstlisting}

	\item \textbf{Creare una stanza}: per creare una stanza basta fornire il nome, dare la possibilita' o meno di essere trovata da altri utenti, fornire la possibilita' agli altri di entrare, e il numero massimo di giocatori.
\begin{lstlisting}
public void OnConnectedToMaster(){
	PhotonNetwork.CreateRoom("RoomName", true, true, 4);
}

\end{lstlisting}	
	
\end{itemize}

Lo studio di Photon Unity Networking non mi e' stato imposto dall'azienda, ma e' stato un approfondimento che ho voluto fare di mia iniziativa per lo sviluppo dell'esempio di contenuto in realta' aumentata a tema libero di cui parlero' successivamente.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{\docsImg Photon.png}
	\caption{Architettura generale del framework Photon Unity Networking}
	\label{fig:Architettura generale del framework Photon Unity Networking}
\end{figure}

PUN si e' dimostrato uno strumento molto potente e relativamente di facile utilizzo. Creare un semplice scambio di dati tra diversi client e' risultato piuttosto semplice. Il livello di difficolta' e' salito quando ho cercato di aumentare il numero di informazioni passate e il numero di oggetti da "osservare". Essendo uno studio non richiesto dall'azienda, ho preferito non spendere troppo tempo in approfondimenti ma piuttosto avere un'idea chiara del funzionamento di base.

\subsubsection{Esempio di contenuto in realta' aumentata a tema libero}
Come ultimo passo a compimento del percorso di preparazione tecnologica e strumentale, e prima di iniziare la realizzazione del progetto principale di stage, mi e' stato chiesto di sviluppare un'applicazione completa con dei contenuti non banali in realta' aumentata. Cio' che mi e' stato reso disponibile per la realizzazione dell'app oltre a Unity 4.6.3 e Vuforia SDK 4, sono stati anche tutti i contenuti gratuiti disponibili sull'Asset Store. Ho quindi proceduto con un'accurata scansione dei contenuti scaricabili trovando cio' che fosse piu' utile per dare luce all'idea ins tato embrionale che avevo in mente.\\\\
Quello che stavo cercando erano dei modelli 3D in stile "cartoon" per lo sviluppo di un videogioco sparatutto multiplayer in realta' aumentata.\\
L'idea che volevo implementare era dare la possibilita' a piu' utenti di interagire sullo stesso tag, e rendere tali interazioni visibili ad utenti che si trovassero dall'altra parte del mondo. La prima idea che mi era venuta, era quella di gestire un oggetto 3D e dare la possibilita' di modificarne la struttura, il colore e la scala agli utenti, in modo che i cambiamenti fossero visibili a tutti gli utenti in osservazione su quel dato tag. Questo pero' non mi e' bastato, in quanto volevo vedere fino a che punto si poteva spingere un device Android con il rendering di contenuti in realta' aumentata. Per cui la realizzazione di un gioco mi sembrava perfetta per testare questi due aspetti.\\

Come gia' detto ho effettuato uno studio di Photon Unity Networking per l'implementazione del multiplayer e successivamente ho proceduto con una semplice progettazione architetturale e con l'implementazione vera e propria.\\

La prima cosa fatta e' stata la realizzazione della mappa di gioco, cercando di renderla il piu' simmetrica possibile in modo da non sfavorire nessuno dei due giocatori e creando delle barriere invisibili per non permettere ai giocatori di poter uscire dallo scenario.\\
Il passo successivo e' stato quello di creare dei punti di respawn e di gestire la nascita dei giocatori in modo casuale sulla mappa. Avendo trovato sull'Asset Store un modello 3D gia' in possesso di animazioni e script che simulassero un soldato cartoon vero e proprio, non ho dovuto occuparmid ella gestione dell'avatar.\\
Una volta creati e gestiti i punti di respawn, e' iniziato il lavoro di configurazione della lobby (contenitore di stanze) in primo luogo, e delle stanze successivamente, fornendo la possibilita' ai giocatori di creare la propria stanza e di vedere le stanze create dagli altri giocatori. Per la lobby e' stata creata una schermata iniziale apposita di scelta dello username e di creazione nuova stanza o accesso a una stanza gia' creata.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{\docsImg cot3.jpg}
	\caption{Schermata iniziale di Call Of Toony con Lobby}
	\label{fig:Schermata iniziale di Call Of Toony con Lobby}
\end{figure}

Inseguito, sono stati gestiti gli script relativi al passaggio dei dati attraverso la rete. In particolare i dati passati sono:

\begin{itemize}
	\item posizione e rotazione dei personaggi rispetto alla mappa;
	\item percentuale di salute rimasta sulla health bar;
	\item bersaglio colpito e chi ha colpito il bersaglio.
\end{itemize}

La gestione di questi dati ha permesso la gestione di un gioco basilare, in cui successivamente e' stata applicata un'area in cui rappresentare i log della partita, quali: spawn dei giocatori e le uccisioni avvenute. Inoltre, localmente e' stato reso disponibile il numero di morti del proprio personaggio, mentre non c'e' stato abbastanza tempo per gestire anche il numero di uccisioni.\\\\
Il risultato e' stato un gioco fluido e ben strutturato, in grado di gestire il multiplayer ad una latenza bassissima e in grado di coinvolgere il giocatore in un'esperienza nuova e unica. I problemi riscontrati sono dovuti unicamente ai device, i quali a lungo termine presentano surriscaldamento, consumo elevato di batteria e un calo di frame per secondo.\\
Il progetto e' piaciuto molto al team tecnico, che non ha escluso la possibilita', dopo un'accurata ottimizzazione, di un inserimento del contenuto in realta' aumentata all'interno dell'app Experenti.\\
Il nome del gioco e' \textbf{Call Of Toony}, in richiamo a titoli videoludici del genere ben piu' noti.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg cot1.jpg}
	\caption{Call Of Toony - multiplayer su device diversi}
	\label{fig:Call Of Toony - multiplayer}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg cot2.jpg}
	\caption{Call Of Toony - schermata di gioco}
	\label{fig:Call Of Toony - schermata di gioco}
\end{figure}

\subsection{Svolgimento delle attivita'}
Inizia ora la stesura di quanto svolto nel progetto vero e proprio, ripercorrendo tutte le fasi del ciclo di vita del software sviluppato fino al suo rilascio sui vari store. Per lo svolgimento del progetto sono state previste circa 120 ore inserite all'interno dell'orario di lavoro aziendale, dal lunedi al venerdi.\\
Il nome dell'applicazione da sviluppare e' Cora' Parquet Live.\\
Lo studio di fattibilita' e' stato fatto dal Project Manager insieme a un collega del reparto tecnico, ed io non ne ho potuto prendere parte.

\subsubsection{Il cliente}
Prima di procedere con gli aspetti tecnici e' bene avere una panoramica su chi e' il cliente che ha commissionato la realizzazione del progetto, quale target di pubblico punta a raggiungere e quali sono le sue aspettative.
\\\\
Il cliente in questione e' \textbf{Cora' Divisione Parquet}, una divisione dell'azienda \textbf{Cora' Legnami}, nata nel 1919. Cora' Parquet e' specializzata nella realizzazione di pavimenti in legno e realizza pavimentazioni per ambienti interni, ambienti esterni e spazi pubblici. L'azienda, leader nel settore, punta a raggiungere i suoi clienti attraverso canali innovativi grazie alla spinta al ringiovanimento voluta da Ettore Cora', amministratore delegato presso Cora' Domenico \& Figli SpA.\\
La richiesta del cliente era la realizzazione di un configuratore in realta' aumentata di pavimentazioni in legno, in grado di essere utilizzato inizialmente a scopo fieristico e successivamente utilizzabile dai clienti finali dell'azienda in modo da avere uno strumento in grado di fare provare le varie linee di prodotto direttamente nelle case dei possibili clienti.\\
Uno degli obiettivi era quello di fare scaturire nel possibile cliente cio' che viene chiamato "fattore wow", lasciando sbalordito il cliente e consolidando nella sua mente la propensione dell'azienda verso l'innovazione e il miglioramento.
Il secondo obiettivo e' dato dal fatto che un'applicazione di un tale livello innovativo inevitabilmente produce un passaparola dagli utenti verso chi ancora non ha visto l'applicazione, generando quindi pubblicita' e maggiore visibilita' all'azienda.\\
Per generare questo "effetto wow", Cora' ha deciso di farsi realizzare un modello tridimensionale di una pin-up con un vestito dilegno. Questo avatar avrebbe dovuto presentare le varie linee di prodotto ed eseguire una introduzione all'applicazione. Il modello e le animazioni non sono state realizzate internamente all'azienda ma sono state delegate a terzi.\\\\
Infine, per quanto riguarda il target dell'app, ci si voleva rivolgere all'utente medio, in grado di poter stampare autonomamente il tag a casa propria. Visto che l'utente finale avrebbe dovuto essere la cosiddetta "signora Maria", ossia un utente senza particolare propensione per tecnicismi informatici e tecnologia in generale, l'applicazione doveva avere un elevato grado di usabilita' e doveva guidare l'utente passo passo.

\subsubsection{Analisi dei requisiti}
Nella metodologia Agile, l'insieme totale dei requisiti e' ottenibile esclusivamente nelle ultime iterazioni, o comunque a progetto quasi ultimato. Questo perche' l'obiettivo principale del modello Agile e' quello di ottenere il massimo soddisfacimento del cliente nei tempi e nei costi preventivati.\\
Alcuni aspetti di rifinitura sono stati quindi concordati in iterazioni intermedie, e sono stati accettati anche se cambiavano molto la struttura del progetto, purche' comunque non si avesse un totale stravolgimento di quanto fatto fino a quel punto.\\
Dopo un'attenta analisi iniziale, sono stati estrapolati i casi d'uso principali dalle richieste del committente, da uno studio sull'utenza finale e basandosi sull'user story.\\
L'analisi dei requisiti e' stata svolta insieme alla Project Manager, la quale a mantenuto i contatti con il responsabile d'azienda esterno per tutta la durata del progetto. Insieme a lei abbiamo stilato una lista di funzionalita' prioritarie e una lista, invece, di requisiti desiderabili e opzionali.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg casi.png}
	\caption{Diagramma dei casi d'uso generico relativo all'applicazione Cora' Parquet Live}
	\label{fig:Diagramma dei casi d'uso generico relativo all'applicazione Cora' Parquet Live}
\end{figure}

Per quanto riguarda i requisiti, essi sono stati suddivisi in 3 categorie: requisiti obbligatori, requisiti opzionali e requisiti desiderabili.\\
Per quanto riguarda i requisiti opzionali, essi sono stati resi obbligatori dall'applicazione dei vincoli metodologici derivati dalle pratiche in uso aziendali.\\\\
Segue ora una lista descrittiva dei principali requisiti. Il presente documento vuole garantire un discreto livello di dettaglio senza annoiare il lettore, per cui verranno elencate solo le funzionalita' principali.\\\\

\textbf{Requisiti obbligatori:}

\begin{itemize}
	
	\item L'applicazione deve eseguire una presentazione iniziale dell'avatar, il quale deve comparire dietro un ventaglio di legno che si apre e deve fare un breve discorso di apertura.
	
	\item L'applicazione deve rendere disponibile un tutorial iniziale che spieghi tutte le funzionalita' dell'app.
	
	\item L'applicazione deve dare la possibilita' all'utente di sfogliare una lista di categorie di prodotto, suddivise alla radice in  "Linea di prodotto" e "Colori", che permetteranno di accedere agli stessi prodotti in due modi diversi. La lista deve essere navigabile in entrambe le direzioni (da padre a figlio e da figlio a padre).
	
	\item Quando una linea di prodotto viene selezionata deve essere data la possibilita' all'utente di avviare una breve presentazione eseguita dall'avatar sulla linea di prodotto scelta. Questo comporta l'apparazione dell'avatar a schermo.
	
	\item L'applicazione deve dare la possibilita' all'utente di visualizzare i prodotti appartenenti a una certa categoria e deve dare la possibilita' di selezionarne uno da visualizzare in realta' aumentata.
	
	\item L'utente deve avere la possibilita' di selezionare un prodotto da una lista di prodotti e di visualizzarlo in realta' aumentata agganciato al tag. Alla selezione del prodotto deve, inoltre, essere disponibile la possibilita' di visualizzare la descrizione del prodotto scelto in un pannello appositamente creato.
	
	\item L'applicazione deve permettere, quando un prodotto e' selezionato e visibile in realta' aumentata, di effettuare modifiche sulla superficie coperta. In particolare, si vuole rendere disponibile all'utente la funzionalita' di pinch-to-scale sull'oggetto parquet.
	
	\item l'applicazione rende disponibile un menu' di "Credits" in cui e' possibile riavviare la presentazione iniziale, rivedere il tutorial, oppure collegarsi alla pagina di download tag, o alla pagina Facebook ufficiale di Cora' Divisione Parquet.
	
	\item L'applicazione deve dare la possibilita' all'utente di richiedere un preventivo online e di scattare uno screenshot della schermata visualizzata.
	
	\item L'applicazione deve contenere almeno i primi 30 prodotti inviati dall'azienda. 
	
\end{itemize}

\textbf{Requisiti desiderabili:}

\begin{itemize}
	\item L'applicazione deve contenere i 21 prodotti inviati in seconda istanza.
	
	\item L'applicazione deve prevedere le gesture di "Swipe" per aprire e chiudere i menu'.
	
	\item Le texture dei prodotti devono utilizzare uno shader speculare per ottenere un'effetto piu lucido.
	
	\item La barra del menu' di navigazione deve essere ingrandita rispetto alla versione base del configuratore.
	
	\item Gli screenshot devono catturare solo la schermata principale con il prodotto in realta' aumentata, il pannellodescrittivo del prodotto e il logo di Cora' Divisione Parquet, niente altro.
\end{itemize}

Come gia' descritto in precedenza, i requisiti hanno visto modifiche anche sostanziali ad ogni iterazione, questo perche' la pratica adottata e' stata un'analisi iniziale seguita da una breve progettazione e da un intenso periodo di implementazione. Al termine di tale periodo, avveniva prima una verifica completa e poi compilata una demo ed inviata al cliente. Il cliente visionava l'app e inviava di ritorno al Project Manager un feedback con le criticita' e le migliorie da apportare. Seguiva, quindi un'ulteriore analisi dei requisiti ed iniziava un nuovo ciclo iterativo.\\\\


\subsubsection{Progettazione}
Nella metodologia Agile, la fase di progettazione e' la piu' importante e difficile da realizzare. Serve infatti molta esperienza per lavorare con una metodologia di questo tipo, in quanto il progetto si ritrova soggetto a continui cambiamenti. Risulta quindi difficile una progettazione solida e duratura, e non si ha il tempo necessario per entrare nel dettaglio, in quanto le ore previste per questa attivita' sono poche e frequenti.\\
Come gia' detto in sezioni precedenti del documento, il configuratore da realizzare doveva partire da un modello di configuratore di base gia' realizzato e implementante un design pattern architetturale Model View Controller, per quanto Unity ne permetta un'implementazione limitata.\\
I design pattern sono strumenti che aiutano a risolvere un certo tipo di problema comune. Quindi, e' necesseria la presenza di un problema per applicare un design pattern che lo risolva.\\
Bisogna sottolineare il fatto che Unity si basa pesantemente attorno alle componenti o ai piu' noti "GameObject", ovvero gli oggetti di gioco, non c'e' modo di aggirare questa cosa.\\\\
Segue ora una descrizione generica di come e' stato progettato il configuratore comprensivo delle funzionalita' offerte di base da un configuratore gia' realizzato e delle parti da me costruite.\\


\begin{figure}[H]
	\centering
	\includegraphics[width=1.1\textwidth]{\docsImg Class.png}
	\caption{Diagramma delle classi generico}
	\label{fig:Diagramma delle classi generico}
\end{figure}
\newpage

In figura \ref{fig:Diagramma delle classi generico} si puo' notare come sia stata organizzata l'architettura dell'applicazione sulla base di cio' che era gia' stato realizzato. In particolare, necessita una spiegazione l'etimologia dei colori del diagramma:

\begin{itemize}
	\item \textbf{Giallo}: le classi colorate in giallo rappresentano classi gia' presenti e realizzate dai colleghi del reparto tecnico a cui non sono state apportate modifiche.
	\item \textbf{Azzurro}: Le classi colorate di azzurro rappresentano le classi gia' implementate a cui pero' e' stata applicata una modifica non banale.
	\item \textbf{Verde}: in verde le classi create da zero.
\end{itemize}

Come e' facile notare dal diagramma, il modello di gestione dei prodotti del configuratore era gia' implementato in una sorta di MVC. Il mio compito e' stato quello di adattare il codice gia' sviluppato perche' si prendesse carico dell'inserimento e della gestione di un nuovo tipo di contenuto. \\
Inoltre, il mio compito principale riguardava la gestione dell'avatar all'interno dell'applicazione e la gestione delle gesture.

\paragraph{Architettura generale}
Da subito sono state definite quelle che avrebbero dovuto essere le entita' principali all'interno dell'applicazione, ovvero:

\begin{itemize}
	\item \textbf{Product}: Classe rappresentante il modello dati di un prodotto, avente il compito di memorizzare tutte le informazioni relative a un parquet, quali: nome, linea, categoria, finitura, codice, descrizione, essenza, scelta, superficie e dimensioni. Inoltre contiene il nome del padre del prodotto e uno sprite di dimensioni 300x300(px) da usare come icona.
	
	\item \textbf{ProductController}: Questa classe si occupa di istanziare l'oggetto 3D rappresentante il prodotto vero e proprio una volta che un prodotto viene selezionato. Il modello 3D viene caricato e istanziato runtime dalle risorse disponibili in base al nome dell'oggetto scelto, che quindi dovra' essere univoco tra i vari prodotti e contenere la stringa "\_3d" in coda.
	
	\item \textbf{HierarchyElement}: Classe che si occupa di gestire genitore e figli del prodotto preso in considerazione.
	
	\item \textbf{DataController}: Questa e' la classe centrale su cui si basa tutto il funzionamento del configuratore. Il compito di questa classe e' quello di gestire la gerarchia completa di prodotti, permettendo di impostare il nome e l'icona delle varie categorie, e di impostare i genitori e le icone di ogni prodotto. Tutto questo puo' essere gestito come plugin di Unity semplicemente attaccando lo script a un GameObject vuoto.
	
	\item \textbf{AvatarPositionController}: Classe principale di gestione e controllo dell'avatar. Qui viene gestito il posizionamento dell'avatar: all'avviod ell'applicazione l'avatar viene posizionato sopra il tag ad una grandezza fissata, successivamente, una volta terminata la presentazione iniziale, l'avatar viene spostato e fissato a schermo in una posizione laterale e non troppo ingombrante. Quando l'avatar e' fissato a schermo ha una scala posta a zero, mentre viene ingrandito una volta richiamato tramite apposito pulsante. Questo script si occupa anche di gestire la posizione e l'apparizione del ventaglio iniziale per poi invocare il metodo dedicato alla presentazione vera e propria dell'avatar.
	
	\item \textbf{StartController}: E' la classe che si occupa di gestire la presentazione iniziale dell'avatar. Qui vengono caricati i file audio e temporizzati con l'inizio delle animazioni. La classe si occupa di gestire sia l'avviosia il termine (anche richiesto dall'utente) dell'applciazione.
	
	\item \textbf{SpeakerAndAnimationController}: Classe realizzata con lo scopo di gestire l'avatar in modo da fargli presentare le categorie tramite animazioni e file audio. Non era conosciuto a priori il numero di animazioni che si sarebbero dovute implementare per cui questa classe doveva essere progettata in modo da gestire un numero indefinito di animazioni e file audio.
	
	\item \textbf{PinchToScale}: Questa classe non si occupa di riconoscere la gesture, compito dedicato a una classe sviluppata da terzi, ma si occupa di definire il comportamento quando viene rilevata una particolare gesture sul modello 3D del prodotto.
	
	\item \textbf{SwipeManager}: Questa classe, come la precedente, non e' un riconoscitore di gesture ma un gestore che si occupa di definirne il comportamento. Lo SwipeManager deve aprire e chiudere i menu' in pase al tipo di swipe effettuato.
	
	\item \textbf{ScreenshotManager}: Si occupa di gestire la cattura e il salvataggio della schermata visualizzata dul display. Lo script si affita all'utilizzo di classi dedicate sviluppate da terzi e ha il compito di gestire cosa deve essere visualizzato nello screenshot.
	
	\item \textbf{CoraMailBuilder}: E' lo script che si occupa della creazioen della mail di richiesta preventivo su un determinato prodotto
	
	\item \textbf{LevelBehaviour}: Questa classe si occupa di popolare il menu' inferiore dell'applicazione, creando i pulsanti per ogni categoria e i pulsanti relativi ai prodotti.
\end{itemize}

Questi sono gli script principali utilizzati nella realizzazione del progetto. Come gia' detto, sono stati creati altri script piu' dedicati e di rifinitura, la cui spiegazione in dettaglio non fara' parte di questo documento per non appesentirne la lettura.\\\\

\paragraph{Layout e GUI}
Per quanto riguarda la GUI dell'applicazione, essa e' stata progettata da terzi per conto di Cora' Divisione Parquet e mi e' stata inviata tramite un file PSD contenente le grafiche da utilizzare e il layout a cui adeguarsi.\\
Il layout e' stato scelto sulla base dei configuratori precedentemente utilizzati ed e' stato adattato per il progetto specifico.

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{\docsImg layout1.jpg}}
	\caption{Layout con menu' info aperto}
	\label{fig:Layout con menu' info aperto}
\end{figure}

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{\docsImg layout2.jpg}}
	\caption{Layout con menu inferiore aperto}
	\label{fig:Layout con menu inferiore aperto}
\end{figure}
\newpage
Di seguito vengono descritti i componenti principali della GUI.

\begin{itemize}
	\item \textbf{Logo}: il logo e' un pulsante cliccabile che apre il menu' dei Credits nel centro dello schermo;
	\item \textbf{Menu' inferiore}: contiene la lista delle categorie, con eventualmente la relativa icona, e la lista dei prodotti come figli della propria categoria madre. Il menu' e' composto da una "breadcumb" navigabile, e da una sequenza di bottoni assegnati ognuno ad una categoria, e nei livelli piu' profondi ai prodotti.
	\item \textbf{Pannello Info}: e' un pannello laterale che compare dopo la pressione del pilsante "i". Il pulsante in questione diventa visibile solo quando un prodotto e' selezionato e permette di aprire la sezione relativa alla descrizione del prodotto. Il pannello si compone anche di un pulsante per l'acquisizione di screenshot e un pulsante per la richiesta di preventivo del prodotto visualizzato.
	\item \textbf{Pulsante animazione}: e' un pulsante a forma di fumetto situato nella parte a est dello schermo, e diventa visibile ogni volta che l'avatar ha qualcosa da dire. Nello specifico, compare quando viene selezionata una categoria interna alle "linee di prodotto", e scompare negli altri casi. La comparsa e' seguita da un'animazione di notifica per richiamare l'attenzione dell'utente. Una volta rpemuto il pulsante, compare l'avatar nella parte ovest dello schermo iniziando l'animazione dedicata.
	\item \textbf{Scope}: mirino posizionato al centro dello schermo e utilizzato per fornire brevi istruzioni all'utente su cosa fare e dare la possibilita' all'utente di scaricare il tag, oltre al fatto di eseguire la sua funzionalita' principale di supporto per mirare il tag.
\end{itemize}

L'apertura del menu', dei credits e del pannello laterale non e' mutualmente esclusiva, in quanto tutte e tre le componenti possono essere visibili in stato aperto contemporaneamente senza interferire tra di loro.\\


In questo capitolo ho avuto voce, in quanto ho potuto esprimere il mio dissenso su alcune scelte relative all'usabilita' dell'applicazione mantenedo un certo tipo di layout. Queste osservazioni e richieste di modifica della grafica sono state concordate prima con Project manager e successivamente con il cliente. Le modifiche osservate e accolte sono state:

\begin{itemize}
	\item Grandezza del pannello delle informazioni laterali. Essendo troppo piccolo risulatava inutilizzabile da smartphone.
	\item Stile dell'icona dell'applicazione che risultava poco leggibile.
	\item Posizione del pulsante animazione. Inizialmente posto nella parte superiore dello schermo, risultava difficile da raggiungere con un'impugnatura standard del device.
\end{itemize}

Inoltre, ho proposto l'utilizzo di un tag di grandezza A3, al posto del foglio A4 utilizzato per ottenere un miglior risultato di agganciamento del tag e di tracking. Questa richiesta non e' stata accolta in quanto si presuppone la stampa domestica del tag in assenza di possibilita' di stampare fogli A3.\\


\paragraph{Animator Controller}
Gli Animator Controller sono i gestori delle animazioni di un GameObject in Unity. Generalmente, ogni oggetto chesi vuole animare ha attaccato un Animator con associato un Animator Controller che ne definisce il comportamento. In questo progetto, tali componenti hanno avuto un ruolo fondamentale, per cui e' stata necessaria un'attenta progettazione di queste componenti.\\
In questo paragrafo verranno tralasciate le spiegazioni degli Animation Controller banali.\\

\begin{itemize}
	\item \textbf{Info Panel Controller}: controller dedicato al pannello laterale per gestire le animazioni entrata, uscita e di oscurazione del pulsante "i". Esempio utile per capire come ogni oggetto della GUI e' stato gestito in modo simile. Ogni animazione viene fatta partire al cambio di stato di un valore booleano oppure all'azionamento di un particolare trigger.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\textwidth]{\docsImg InfoPanelController.png}
		\caption{Animator Controller del pannello Info laterale}
		\label{fig:Animator Controller del pannello Info laterale}
	\end{figure}
	
	Nel dettaglio: INFO\_DEF nasconde sia pannello che pulsante, INFO\_HIDE mostra il pulsante "i", INFO\_SHOW apre il pannello su schermo, INFO\_SHOT, rimuove gli elementi della GUI indesiderati per l'esecuzione di uno screenshot.
	
	\item \textbf{Avatar Speaker Controller}: dedicato alla gestione della presentazione iniziale da parte dell'avatar e alle animazioni relative alla spiegazione delle categorie.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\textwidth]{\docsImg AvatarSpeakerController.png}
		\caption{Animator Controller dell'avatar}
		\label{fig:Animator Controller dell'avatar}
	\end{figure}
	
	Nel dettaglio: IDLE e' lo stato iniziale, a cui l'avatar ritorna alla fine di ogni presentazione. Lo stato PRESENTATION e' un particolare stato in cui l'animator viene portato nel momento in cui si vuole avviare la presentazione iniziale. Questo stato termina poi con il passaggio a END\_PRESENTATION che e' uno stato necessario per effettuare alcuni controlli da codice, come controllare che la presentazione sia terminata. Lo stesso viene fatto con le n categorie di prodotti di cui si ha la presentazione.\\ Questo animator poteva essere implementato in modo piu' efficiente caricando l'animazione da fare partire di volta in volta in base a una stringa passata. Avendo tempo limitato si e' preferito procedere per una strada di facile implementazione come questa.
\end{itemize}






\subsubsection{Implementazione}
L'attivita' di implementazione e di codifica si e' svolta secondo quanto previsto dalla metodologia Agile. Le fasi di codifica non son avvenute in un unico round, ma in brevi e frequenti blocchi di tempo. Per prima cosa, sono state implementate le parti principali del sistema, cioe' le parti che quasi sicuramente non avrebbero avuto modifiche nelle successive iterazioni.\\

Si e' proceduto, in primo luogo, con l'adattamento di quanto disponibile nel configuratore base. In particolare e' stata creata una classe Product in grado di contenere tutte le informazioni necessarie per ogni prodotto.\\

\paragraph{Pinch-To-Scale}
E' stata richiesta la possibilita' di espandere il parquet mostrato in realta' aumentata direttamente runtime tramite l'applicazione di una gesture dedicata.\\
Bisogna premettere che le texture dei parquet sono state recapitate simulandone la grandezza reale per cui, data anche l'irregolarita' di alcuni parquet, era difficile fare il tiling (ripetizione della texture su uno o piu'assi) della texture.\\
Su suggerimento del CTO si e' deciso di procedere mantenedo la dimensione reale della texture, senza tiling, e applicando una maschera ridimensionabile all'oggetto in modo tale da visualizzarne solo una parte. La realizzazioen e' stata affidata completamente a me.\\
E' stata realizzata una maschera a forma di cornice, unendo piu' oggetti tridimensionali prefabbricati. A tale maschera e' stato poi applicato un particolare shader in grado di rimuovere il rendering delle parti di texture coperte dalla maschera.\\
Di seguito e' illustrata la codifica relativa allo script PinchToScale.cs.

\begin{lstlisting}

public class PinchToScale : MonoBehaviour
{
public Vector3 scaleWeights = Vector3.one;
public float minScaleAmount = 0.4f;
public float maxScaleAmount = 4.0f;
public float sensitivity = 0.3f;		// augment for a bigger scaling
public float smoothingSpeed = 12.0f;    // set to 0 to disable smoothing
public GameObject mask;

private float idealScaleAmount = 0.4f;
private float scaleAmount = 0.4f;
private Vector3 baseScale = Vector3.one;

public float ScaleAmount
{
	get { return scaleAmount; }
	
	set 
	{ 
		value = Mathf.Clamp( value, minScaleAmount, maxScaleAmount );	//check if the value is between limits
		
		if( value != scaleAmount )
		{
			scaleAmount = value;
			
			Vector3 s = scaleAmount * baseScale;
			s.x *= scaleWeights.x;
			s.y *= scaleWeights.y;
			s.z *= scaleWeights.z;
			
			mask.transform.localScale = s;			//resize the mask scale
		}
	}
}

public float IdealScaleAmount
{
	get { return idealScaleAmount; }
	set { idealScaleAmount = Mathf.Clamp( value, minScaleAmount, maxScaleAmount ); }
}

void Start()
{
	baseScale = transform.localScale;
	IdealScaleAmount = ScaleAmount;
}

void Update()
{
	if (smoothingSpeed > 0) {
		ScaleAmount = Mathf.Lerp (ScaleAmount, IdealScaleAmount, Time.deltaTime * smoothingSpeed);
	} else {
	ScaleAmount = IdealScaleAmount;
}
}

void OnPinch( PinchGesture gesture )
{  
	IdealScaleAmount += sensitivity * gesture.Delta.Centimeters();
} 
\end{lstlisting}

Il codice, all'avvio dello script, memorizza la scala locale dell'oggetto, e imposta il valore di scaling ideale allo scaling di base. Ad ogni frame viene aggiornato, internamente al metodo Update, lo scaling attuale, sia nel caso sia presente un effetto di smooth sia altrimenti. Quando viene catturata una gesture di Pinch, ne viene presa l'ampiezza in centimetri e moltiplicata per la sensibilita' che gli si vuole dare allo scaling rispetto alla gesture. Questo valore calcolato viene memorizzato in IdealScaleAmount che nel successivo Update sara' memorizzato come nuovo valore di ScaleAmount. ScaleAmount ogni volta che viene modificato si occupa di applicare lo scaling impostato alla maschera passata come parametro da Unity.\\\\


\paragraph{Inserimento prodotti}
Successivamente ho proceduto con l'inserimento dei primi 20 prodotti, in quanto il modello e la gestione delle categorie e dei prodotti era gia' implementata. Per ogni prodotto, prima si e' dovuta importare negli assets la relativa texture e icona, poi, dopo aver attaccato uno script Product al prodotto comprensivo del modello 3D, questo veniva processato in uno script (VariationMaker.cs) che creava 2 oggetti: un GameObject contenente le informazioni del prodotto da utilizzare nello script di gestione dei dati (DataController.cs) e un GameObject con il modello 3D.\\

\paragraph{Gestione dell'avatar}
Come gia' accennato, il grosso del lavoro consistava nell'implementazione di un avatar all'interno dell'applicazione. Per prima cosa e' stato gestita la presentazione iniziale composta da 4 file di animazione e 4 file audio. E' stata usata la tecnica del lip sync per ottenere un effetto realistico. Di cio' se ne e' occupato lo StartController sviluppato appositamente.\\
Lo StartController e' stato implementato utilizzando il design pattern Singleton in quanto era necessario avere al piu' un'istanza della classe.\\

All'avvio dello StartController vengono caricati in memoria gli audio file relativi alla presentazione. Durante ogni ciclo di Update, invece, viene controllato lo stato dell'animazione corrente e il numero contenuto all'interno di un particolare contatore. In questo modo e' possibile eseguire nell'ordine corretto i vari pezzi ottenendo, cosi, l'animazione completa, senza che venga ciclata piu' volte essendo che il contatore procede verso un'unica direzione incrementale e viene ripristinato solo quando si vuole riavviare la presentazione.\\

Di seguito viene mostrata la codifica del metodo Awake() che si occupa del caricamento dei file audio.
\begin{lstlisting}
	void Awake() {
		_instance = this;
		pt1 = (AudioClip)Resources.Load ("Speakeraggio/01_Presentazione1", typeof(AudioClip));
		pt2 = (AudioClip)Resources.Load ("Speakeraggio/02_Presentazione2", typeof(AudioClip));
		pt3 = (AudioClip)Resources.Load ("Speakeraggio/03_Presentazione3", typeof(AudioClip));
		pt4 = (AudioClip)Resources.Load ("Speakeraggio/04_Presentazione4", typeof(AudioClip));
	}
\end{lstlisting}

E il metodo Update() che si occupa della gestione delle animazioni e della sincronizzazione con i file audio. Inoltre si puo' notare come venga reso disponibile un pulsante "Skip" per saltare la presentazione.
\begin{lstlisting}
	void Update(){
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("01_Presentazione1") && startLock == 1) {
			presentationAudio.clip = pt1;
			presentationAudio.Play();
			skipButton.SetActive(true);
			skipButton.GetComponent<Animator> ().SetBool ("Show", true);
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("02_Presentazione2") && startLock == 2) {
			presentationAudio.clip = pt2;
			presentationAudio.Play();
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("03_Presentazione3") && startLock == 3) {
			presentationAudio.clip = pt3;
			presentationAudio.Play();
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("04_Presentazione4") && startLock == 4) {
			presentationAudio.clip = pt4;
			presentationAudio.Play();
			startLock++;
		}
		if (avatarController.GetCurrentAnimatorStateInfo (0).IsName ("EndPresentation") && startLock == 5) {
			EndPresentation ();
			startLock = 1;
		}
	
	}
\end{lstlisting}

Il passo di implementazione successivo e' stato la gestione della posizione dell'avatar. All'inizio doveva risultare agganciato al tag per poi spostarsi e rimanere agganciato alla parte ovest dello schermo, comparendo solo su richiesta.\\
Questo script e' quello che piu' ha usufruito della metofologia Agile, e in particolare quello che ha subito piu' incrementi nelle varie iterazioni.\\
Questo perche' il cliente, non essendo un esperto di realta' aumentata e, soprattutto di applicazioni Android, non aveva un'idea precisa di come e dove dovesse apparire l'avatar. Per cui sono state richieste numerose prove per ottenere il risultato che piu' rendesse felice il cliente.\\
In iterazioni intermedie era sta prevista persino un'interessante funzionalita' per cui il device calcolava l'altezza rispetto al tag e modificava la grandezza dell'avatar per una visione "da alzati" e una "da seduti". Questa funzionalita' da me realizzata e' piaciuta molto al team di sviluppo ma e' stata bocciata dal cliente finale che, alla fine, e' stato convinto del Project Manager della soluzione ottimale con avatar di grandezza fissa.\\
Questo script e' fondamentale perche' gestisce le animazioni dei vari componenti che agiscono nella presentazione iniziale e le sincronizza per ottenere il miglior effetto visivo.\\\\





\subsubsection{Verifica e validazione}

\subsection{Livello di completezza raggiunto}