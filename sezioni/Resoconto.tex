\section{Resoconto dello stage}
\subsection{Pianificazione di progetto}
\subsubsection{Descrizione generale}
Come gi\`a detto in precedenza, lo stage \`e stato suddiviso in due parti: la prima orientata alla formazione su strumenti e tecnologie e la seconda parte orientata alla realizzazione di progetti destinati ai clienti esterni. Come tale, l’attività di formazione \`e stata opportunamente orientata all’apprendimento, da parte mia, delle meccaniche e delle norme vigenti internamente per lo sviluppo di tali progetti, oltre che alla normale parte di formazione tecnica prevista per portare a termine in maniera opportuna le attività dei progetti stessi.
L’obiettivo finale dello stage \`e stato quindi quello di inserirmi come parte integrante del team di sviluppo per i progetti esterni, attribuendomi responsabilità e compiti adeguati al mio ruolo e orientati alle attività di produzione, \textit{testing} e \textit{delivery} di app \textit{mobile} di Realtà Aumentata; la valutazione finale da parte del tutor aziendale \`e stata quindi effettuata sulla base sia della qualità sia della quantità delle attività portate a termine nella fase produttiva finale, oltre che alla capacità di lavorare correttamente in squadra con l’obiettivo comune di consegnare un prodotto finale nei tempi e nelle modalità stabilite.
\\\\
Nel periodo antecedente l'inizio dello stage, insieme al tutor aziendale, sono state concordate le attivit\`a principali che avrei dovuto svolgere durante il periodo seguente della durata di 2 mesi. Nella descrizione delle attivit\`a, riportata nella sezione successiva, \`e stata fornita una descrizione molto generica per quanto riguarda il progetto principale che avrei dovuto seguire, in quanto non era ancora chiaro a priori se ci sarebbe stata o meno la possibilit\`a di seguire un progetto commissionato dall'esterno.
\\\\
La dislocazione temporale delle attivita \`e stata rappresentata graficamente in un Diagramma di Gantt\gloss\ che mi ha aiutato ad avere sempre una visione accurata sullo stato del mio stage, in particolare su eventuali ritardi. Rispetto al diagramma concordato nel piano di lavoro, il mio stage \`e partito dopo 2 giorni rispetto a quanto concordato a causa di un'indisponibilit\`a del tutor aziendale, per cui \`e stata rifatta la pianificazione tenendo conto di questo ritardo.

\begin{figure}[H]
	\centering
	\includegraphics[width=1.1\textwidth]{\docsImg Gantt.png}
	\caption{Diagramma di Gantt\gloss\ delle attivit\`a}
	\label{fig:Diagramma di Gantt delle attivita}
\end{figure}

Il Diagramma di Gantt\gloss\ riportato in figura \ref{fig:Diagramma di Gantt delle attivita} mostra piuttosto fedelmente quanto svolto durante il periodo in azienda ed eventuali anticipi sulla tabella di marcia sono stati riempiti con approfondimenti sulle tecnologie e sessioni di ricerca e sviluppo su visori Google Cardboard. Non ci sono stati, invece, ritardi su quanto preventivato.

\subsubsection{Dettaglio delle attivit\`a}
Di seguito vengono elencate in dettaglio le attivit\`a svolte durante il periodo di stage presso l'azienda ospitante Experenti. Un approfondimento per le principali. 

\begin{enumerate}
	\item	Formazione sulle tecnologie utilizzate internamente per lo sviluppo, quali \textit{framework} e SDK. In particolare:
	
	\begin{enumerate}	
		\item	Ambiente di sviluppo (IDE\gloss) utilizzato (Unity3D) e fondamenti dei sistemi operativi mobile (Android e iOS); 
		\item	Formazione sulle librerie utilizzate internamente per l’elaborazione delle immagini per la realtà aumentata e per il successivo riconoscimento delle stesse in ambiente mobile; 
		\item	Formazione sull’app Experenti: nascita del progetto, funzionamento attuale, obiettivi di sviluppo. Formazione sulle procedure \textit{standard} applicate internamente.	
	\end{enumerate}
	
	\item	Realizzazione di un esempio di contenuto in Realtà Aumentata a tema libero. Questo contenuto, il cui sviluppo è stato necessario alla comprensione del flusso di lavoro interno e all'individuazione di determinate problematiche relative all’ambito AR mobile, ha particolari caratteristiche, quali animazioni e/o movimenti di parti specifiche, un certo grado di interattività e prevede parti semplici di grafica GUI\gloss\ (su schermo, in modalità HUD). E' stata richiesta, inoltre, l’individuazione di un tag adatto al riconoscimento dalle fotocamere \textit{mobile}, possibilmente legato alla tematica che \`e stata sviluppata.
	\item	Analisi di casi di studio e app varie già realizzate internamente. Focus particolare sui progetti base già realizzati e sulla loro struttura: progetto base demo, progetto base visore AR, progetto base configuratore. In questa fase \`e avvenuta la formazione sul flusso di lavoro standard interno all’azienda e sul normale iter di un progetto commissionato da un cliente, dalla ricezione dei materiali fino alla fase di distribuzione (sia essa una distribuzione ad hoc o una distribuzione pubblica tramite \textit{Store mobile}) ed \`e iniziato l'affiancamento al \textit{Project Manager} nelle fasi di accettazione materiali. 
	\item	Realizzazione di un’app demo completa. Per app demo si intende un’app a distribuzione solitamente ad hoc (non pubblicata sugli \textit{Store}) resa disponibile dall’azienda per i propri clienti o \textit{reseller}, comprendente un numero solitamente limitato di contenuti semplici (3D o video) fruibili dall’utente in realtà aumentata attraverso l’uso di un tag fornito dal cliente stesso. L’app possiede, inoltre, una GUI\gloss\ minimale ma personalizzata con il logo del cliente stesso, nonchè un’icona e una \textit{splashscreen} anch’esse personalizzate allo stesso modo. Richiesto l'affiancamento al \textit{Project Manager} fin dalla fase iniziale di ricezione materiali, e prosecuzione poi in autonomia nella fase di sviluppo fino alla fase di rilascio e consegna (previa verifica del risultato prodotto da parte del Tutor Aziendale). L’entità dell’app demo \`e stata stabilita dal \textit{Project Manager} aziendale alcuni giorni prima dell’inizio di questa fase e si \`e data preferenza, alla produzione di una demo per un cliente esterno. 
	\item	Inserimento effettivo nel \textit{team} di sviluppo per i progetti esterni. In questa fase, inizia l'affiancamento al \textit{team} di sviluppo per i progetti commissionati dai clienti esterni; \`e iniziato quindi il coordinamento dal \textit{Project Manager} aziendale nell’assegnazione di task appositi comprendenti le fasi di sviluppo e testing di intere app semplici o parti di app complesse; si \`e preferito assegnare la realizzazione di almeno un’app semplice nella sua interezza commissionata da un cliente esterno. L’assegnazione delle attività \`e stata effettuata attraverso il sistema di \textit{ticketing} utilizzato internamente all’azienda, attraverso il quale \`e stato anche richiesto di rendicontare le proprie attività in termini di tempo utilizzato per ciascuna di esse, mentre l’assegnazione dei singoli \textit{task} \`e stata effettuato dal \textit{Project Manager} aziendale in collaborazione con il tutor aziendale. E' stato valutato positivamente in questa fase la capacità di attenersi alle tempistiche date e il livello di dettaglio fornito nella successiva rendicontazione delle ore, oltre ovviamente alla qualità intrinseca del risultato prodotto. 
\end{enumerate}

\begin{center}
	
	\begin{longtable}{c| p{0.7\textwidth}| c}

		\textbf{Sezione} & \textbf{Descrizione} & \textbf{Ore di lavoro}\\ \cline{1-3}
		\phantomsection
		1.1&  Formazione su ambienti di sviluppo&  40 \\
				\phantomsection
		1.2&  Formazione su librerie utilizzate&  28 \\
				\phantomsection
		1.3&  Formazione sull’app Experenti&  12 \\
				\phantomsection
		2&  Realizzazione di un contenuto di realtà aumentata a tema libero&   56\\	
				\phantomsection
		3&  Analisi su progetti già realizzati internamente e formazione su flusso di lavoro interno&   40\\
				\phantomsection	
		4&  Realizzazione di un’app demo completa&   24\\
				\phantomsection					
		5&  Inserimento nel team di sviluppo e realizzazione di un’app nella sua interezza&   120\\ \cline{1-3}
				\phantomsection
		  & \textbf{TOTALE} & \textbf{320}  \\\\
		  		\caption{Tabella relativa alle ore dedicate per ciascuna attivit\`a}\\
	\end{longtable}
		
\end{center}

\subsection{Studio delle tecnologie e strumenti}
In questa sezione, vengono spiegate le attivit\`a di apprendimento svolte per imparare l'utilizzo delle nuove tecnologie e degli strumenti usati.
\subsubsection{Unity 3D}
Unity, come gi\`a detto in precedenza \`e un sistema \textit{cross-platform\gloss} per lo sviluppo di giochi composto da un \textit{game engine} e da un IDE\gloss\ integrato. Unity viene usato internamente all'azienda per lo sviluppo di app \textit{mobile} distribuite su Android e iOS.
\\
Unity nel suo sito fornisce un grosso supporto agli sviluppatori rendendo disponibile una documentazione completa e una sezione ben fornita di \textit{tutorial} testuali e video suddivisi per categoria.\\
Inizialmente, ho dovuto seguire una parte di video \textit{tutorial} riguardanti l'interfaccia di Unity, lo \textit{scripting}, la gestione della fisica, animazioni e gestione della GUI\gloss . Questo primo periodo si \`e svolto integrando, oltre alla visione, anche la prova diretta sull'\textit{editor} in modo da assimilare meglio i concetti appresi.\\
Nel caso in cui avessi voluto approfondire un argomento oppure non lo avessi ritenuto abbastanza chiaro, avevo sempre la possibilit\`a di ottenere una spiegazione da parte del \textit{tutor} aziendale, il quale si \`e dimostrato sempre molto disponibile anche nel ripetere pi\`u volte lo stesso concetto.\\
In questa parte di formazione, dopo aver seguito e implementato un \textit{tutorial} riguardante l'animazione di un \textit{avatar\gloss}, di mia iniziativa, ho effettuato il porting dell'applicazione su Android gestendo \textit{touch} e \textit{multi-touch} sullo schermo e impostando i movimenti dell'\textit{avatar\gloss} basandoli sull'acelerometro del dispositivo \textit{mobile}.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg tutorial.jpg}
	\caption{Implementazione in Unity del \textit{tutorial} riguardante l'animazione di un \textit{avatar\gloss} 3D di cui successivamente \`e stato eseguito il \textit{porting} su Android}
	\label{fig:tutorial riguardante l'animazione di un avatar\gloss 3D}
\end{figure}
 
\subsubsection{Vuforia SDK}
Terminata la parte di formazione su Unity 3D, \`e iniziata la parte di preparazione relativa a Vuforia SDK, l'SDK utilizzato dall'azienda per l'implementazione della realt\`a aumentata. Nello specifico, il \textit{team} tecnico si \`e occupato di spiegarmi come funziona l'SDK, e come funziona nello specifico il \textit{plugin} di Unity, grazie alla quale è possibile operare all’interno di un unico ambiente di lavoro. Le attivit\`a principali svolte in questo lasso di tempo sono state l'implementazione di modelli 3D e di video associati ai tag, e lo studio sul riconoscimento e la creazione di tag ottimali.

\subsubsection{Photon Unity Networking}
\textit{Photon Unity Networking} (PUN) \`e un \textit{framework} di Unity per l'implementazione del \textit{multiplayer realtime} nei giochi o nelle applicazioni sviluppate. Le applicazioni svilupapte con Photon vengono eseguite su un \textit{server} \textit{cloud} proprietario. Quindi, le operazioni di \textit{scaling} e di \textit{service hosting} sono gestite interamente da PUN, permettendo allo sviluppatore di concentrarsi puramente sulla costruzione dell'applicazione. Tutti i prodotti Photon Cloud sono basati su un'architettura \textit{client-server\gloss}, che \`e la soluzione ottimale per il \textit{gaming online} rispetto ad una connessione \textit{peer-to-peer}.\\
Photon \`e un \textit{package} scaricabile dall'\textit{Asset Store} (negozio di Unity \textit{online} in cui comprare o scaricare gratuitamente \textit{asset\gloss} come \textit{script}, modelli 3D e 2D, etc.), e nella sua versione gratuita prevede l'accesso concorrente fino a 20 utenti sulla stessa stanza. \\\\
Di seguito vengono riportati esempi di codice per mostrare la semplicit\`a di utilizzo del \textit{framework}.\\
\begin{itemize}
	\item \textbf{Connessione al \textit{server}}: La connessione al \textit{server} si basa sul passaggio di una stringa contenente la versione dell'applciazione. Pu\`o essere usata per dividere gruppi di \textit{client}.
\begin{lstlisting}
PhotonNetwork.ConnectUsingSettings("1.0");
\end{lstlisting}

	\item \textbf{Accesso a una stanza}: Per prendere parte a una partita esistente basta la seguente riga di codice specificando il nome della stanza in cui si vuole entrare.
\begin{lstlisting}
PhotonNetwork.JoinRoom("RoomName");
\end{lstlisting}

	\item \textbf{Creare una stanza}: per creare una stanza basta fornire il nome, dare la possibilit\`a o meno di essere trovata da altri utenti, fornire la possibilit\`a agli altri di entrare, e il numero massimo di giocatori.
\begin{lstlisting}
public void OnConnectedToMaster(){
	PhotonNetwork.CreateRoom("RoomName", true, true, 4);
}

\end{lstlisting}	
	
\end{itemize}

Lo studio di \textit{Photon Unity Networking} non mi \`e stato imposto dall'azienda, ma \`e stato un approfondimento che ho voluto fare di mia iniziativa per lo sviluppo dell'esempio di contenuto in realt\`a aumentata a tema libero di cui parler\`o successivamente.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{\docsImg Photon.png}
	\caption{Architettura generale del \textit{framework Photon Unity Networking}}
	\label{fig:Architettura generale del framework Photon Unity Networking}
\end{figure}

PUN si \`e dimostrato uno strumento molto potente e relativamente di facile utilizzo. Creare uno scambio di dati tra diversi \textit{client} \`e risultato piuttosto semplice. Il livello di difficolt\`a \`e salito quando ho cercato di aumentare il numero di informazioni passate e il numero di oggetti da "osservare". Essendo uno studio non richiesto dall'azienda, ho preferito non spendere troppo tempo in approfondimenti, ma piuttosto avere un'idea chiara del funzionamento di base.

\subsubsection{Esempio di contenuto in realt\`a aumentata a tema libero}
Come ultimo passo a compimento del percorso di preparazione tecnologica e strumentale, e prima di iniziare la realizzazione del progetto principale di stage, mi \`e stato chiesto di sviluppare un'applicazione completa con dei contenuti non banali in realt\`a aumentata. Ci\`o che mi \`e stato reso disponibile per la realizzazione dell'app oltre a Unity 4.6.3 e Vuforia SDK 4, sono stati anche tutti i contenuti gratuiti disponibili sull'\textit{Asset Store}. Ho quindi proceduto con un'accurata scansione dei contenuti scaricabili trovando ci\`o che fosse pi\`u utile per dare luce all'idea in stato embrionale che avevo in mente.\\\\
Quello che stavo cercando erano dei modelli 3D in stile "\textit{cartoon}" per lo sviluppo di un videogioco sparatutto \textit{multiplayer} in realt\`a aumentata.\\
L'idea che volevo implementare era dare la possibilit\`a a pi\`u utenti di interagire sullo stesso tag, e rendere tali interazioni visibili ad utenti che si trovassero dall'altra parte del mondo. La prima idea che mi era venuta, \`e stata quella di gestire un oggetto 3D e dare la possibilit\`a di modificarne la struttura, il colore e la scala agli utenti, in modo che i cambiamenti fossero visibili a tutti gli utenti in osservazione su quel dato tag. Questo, per\`o, non mi \`e bastato, in quanto volevo vedere fino a che punto si poteva spingere un \textit{device} Android con il \textit{rendering} di contenuti in realt\`a aumentata. Per cui la realizzazione di un gioco mi sembrava perfetta per testare questi due aspetti.\\

Come gi\`a detto, ho effettuato uno studio di \textit{Photon Unity Networking} per l'implementazione del \textit{multiplayer} e successivamente ho proceduto con una semplice progettazione architetturale e con l'implementazione vera e propria.\\

La prima cosa che ho fatto \`e stata la realizzazione della mappa di gioco, cercando di renderla il pi\`u simmetrica possibile in modo da non sfavorire nessuno dei due giocatori e creando delle barriere invisibili per non permettere ai giocatori di poter uscire dallo scenario.\\
Il passo successivo \`e stato quello di creare dei punti di \textit{respawn} e di gestire la nascita dei giocatori in modo casuale sulla mappa. Avendo trovato nell'\textit{Asset Store} un modello 3D gi\`a in possesso di animazioni e \textit{script} che simulassero un soldato \textit{cartoon} vero e proprio, non ho dovuto occuparmidella gestione dell'\textit{avatar\gloss}.\\
Una volta creati e gestiti i punti di \textit{respawn}, ho iniziato il lavoro di configurazione della \textit{lobby} (contenitore di stanze) in primo luogo, e delle stanze successivamente, fornendo la possibilit\`a ai giocatori di creare la propria stanza e di vedere le stanze create dagli altri giocatori. Per la \textit{lobby} ho creatoa una schermata iniziale apposita di scelta dello \textit{username} e di creazione nuova stanza o accesso a una stanza gi\`a creata.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{\docsImg cot3.jpg}
	\caption{Schermata iniziale di Call Of Toony con \textit{Lobby}}
	\label{fig:Schermata iniziale di Call Of Toony con Lobby}
\end{figure}

In seguito, sono stati gestiti gli \textit{script} relativi al passaggio dei dati attraverso la rete. In particolare, i dati passati sono:

\begin{itemize}
	\item posizione e rotazione dei personaggi rispetto alla mappa;
	\item percentuale di salute rimasta sulla \textit{health bar};
	\item bersaglio colpito e chi ha colpito il bersaglio.
\end{itemize}

La gestione di questi dati ha permesso la creazione di un gioco basilare, a cui, successivamente, ho aggiunto un'area in cui rappresentare i \textit{log} della partita su un angolo di schermo, quali: \textit{spawn} dei giocatori e le uccisioni avvenute. Inoltre, localmente ho reso disponibile il numero di morti del proprio personaggio, mentre non c'\`e stato abbastanza tempo per gestire anche il numero di uccisioni.\\\\
Il risultato \`e stato un gioco fluido e ben strutturato, in grado di gestire il \textit{multiplayer} ad una latenza bassissima e in grado di coinvolgere il giocatore in un'esperienza nuova e unica. I problemi riscontrati sono dovuti unicamente ai \textit{device}, i quali a lungo termine presentano surriscaldamento, consumo elevato di batteria e un calo di \textit{frame} per secondo.\\
Il progetto \`e piaciuto molto al \textit{team} tecnico, che non ha escluso la possibilit\`a, dopo un'accurata ottimizzazione, di un inserimento del contenuto in realt\`a aumentata all'interno dell'app Experenti.\\
Il nome del gioco \`e \textbf{Call Of Toony}, in richiamo a titoli videoludici del genere ben pi\`u noti.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg cot1.jpg}
	\caption{Call Of Toony - \textit{multiplayer} su device diversi}
	\label{fig:Call Of Toony - multiplayer}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg cot2.jpg}
	\caption{Call Of Toony - schermata di gioco}
	\label{fig:Call Of Toony - schermata di gioco}
\end{figure}

\subsection{Svolgimento delle attivit\`a}
Inizia ora la stesura di quanto svolto nel progetto vero e proprio, ripercorrendo tutte le fasi del ciclo di vita del \textit{software\gloss} sviluppato fino al suo rilascio sui vari \textit{store}. Per lo svolgimento del progetto sono state previste circa 120 ore inserite all'interno dell'orario di lavoro aziendale, dal lunedi al venerdi.\\
Il nome dell'applicazione da sviluppare \`e Cor\`a Parquet Live.\\
Lo studio di fattibilit\`a \`e stato fatto dal \textit{Project Manager} insieme ad un collega del reparto tecnico, ed io non ne ho potuto prendere parte.

\subsubsection{Il cliente}
Prima di procedere con gli aspetti tecnici \`e bene avere una panoramica su chi \`e il cliente che ha commissionato la realizzazione del progetto, quale \textit{target} di pubblico punta a raggiungere e quali sono le sue aspettative.
\\\\
Il cliente in questione \`e \textbf{Cor\`a Divisione Parquet}, una divisione dell'azienda \textbf{Cor\`a Legnami}, nata nel 1919. Cor\`a Parquet \`e specializzata nella realizzazione di pavimenti in legno e realizza pavimentazioni per ambienti interni, ambienti esterni e spazi pubblici. L'azienda, \textit{leader} nel settore, punta a raggiungere i suoi clienti attraverso canali innovativi grazie alla spinta al ringiovanimento voluta da Ettore Cor\`a, amministratore delegato presso Cor\`a Domenico \& Figli SpA.\\
La richiesta del cliente era la realizzazione di un configuratore in realt\`a aumentata di pavimentazioni in legno, in grado di essere utilizzato inizialmente a scopo fieristico e successivamente utilizzabile dai clienti finali dell'azienda in modo da avere uno strumento in grado di fare provare le varie linee di prodotto direttamente nelle case dei possibili clienti.\\
Uno degli obiettivi era quello di fare scaturire nel cliente ci\`o che viene chiamato "fattore wow", lasciando sbalordito l'utente e consolidando nella sua mente la propensione dell'azienda verso l'innovazione e il miglioramento.
Il secondo obiettivo \`e dato dal fatto che un'applicazione di un tale livello innovativo inevitabilmente produce un passaparola dagli utenti verso chi ancora non ha visto l'applicazione, generando quindi pubblicit\`a e maggiore visibilit\`a all'azienda.\\
Per generare questo "effetto wow", Cor\`a ha deciso di farsi realizzare un modello tridimensionale di una pin-up con un vestito di legno. Questo \textit{avatar\gloss} avrebbe dovuto presentare le varie linee di prodotto ed eseguire una introduzione all'applicazione. Il modello e le animazioni non sono state realizzate internamente all'azienda ma sono state delegate a terzi.\\\\
Infine, per quanto riguarda il \textit{target} dell'app, ci si voleva rivolgere all'utente medio, in grado di poter stampare autonomamente il tag a casa propria. Visto che l'utente finale avrebbe dovuto essere la cosiddetta "signora Maria", ossia un utente senza particolare propensione per tecnicismi informatici e tecnologia in generale, l'applicazione doveva avere un elevato grado di usabilit\`a e doveva guidare l'utente passo dopo passo.

\subsubsection{Analisi dei requisiti}
Nella metodologia Agile, l'insieme totale dei requisiti \`e ottenibile esclusivamente nelle ultime iterazioni, o comunque a progetto quasi ultimato. Questo perch\`e l'obiettivo principale del modello Agile \`e quello di ottenere il massimo soddisfacimento del cliente nei tempi e nei costi preventivati.\\
Alcuni aspetti di rifinitura sono stati quindi concordati in iterazioni intermedie, e sono stati accettati anche se cambiavano molto la struttura del progetto, purch\`e comunque non si avesse un totale stravolgimento di quanto fatto fino a quel punto.\\
Dopo un'attenta analisi iniziale, sono stati estrapolati i casi d'uso principali dalle richieste del committente, da uno studio sull'utenza finale e basandosi sulla\textit{user story}.\\
L'analisi dei requisiti \`e stata svolta insieme al \textit{Project Manager}, il quale a mantenuto i contatti con il responsabile d'azienda esterno per tutta la durata del progetto. Insieme, abbiamo stilato una lista di funzionalit\`a prioritarie e una lista, invece, di requisiti desiderabili e opzionali.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{\docsImg casi.png}
	\caption{Diagramma dei casi d'uso generico relativo all'applicazione Cora' Parquet Live}
	\label{fig:Diagramma dei casi d'uso generico relativo all'applicazione Cora' Parquet Live}
\end{figure}

Per quanto riguarda i requisiti, essi sono stati suddivisi in 3 categorie: requisiti obbligatori, requisiti opzionali e requisiti desiderabili.\\
Per quanto riguarda i requisiti opzionali, essi sono stati resi obbligatori dall'applicazione dei vincoli metodologici derivati dalle pratiche in uso aziendali.\\\\
Segue ora una lista descrittiva dei principali requisiti. Il presente documento vuole garantire un discreto livello di dettaglio senza annoiare il lettore, per cui verranno elencate solo le funzionalit\`a principali.\\\\

\textbf{Requisiti obbligatori:}

\begin{itemize}
	
	\item L'applicazione deve eseguire una presentazione iniziale dell'\textit{avatar\gloss}, il quale deve comparire dietro un ventaglio di legno che si apre e deve fare un breve discorso di apertura.
	
	\item L'applicazione deve rendere disponibile un \textit{tutorial} iniziale che spieghi tutte le funzionalit\`a dell'app.
	
	\item L'applicazione deve dare la possibilit\`a all'utente di sfogliare una lista di categorie di prodotto, suddivise alla radice in  "Linea di prodotto" e "Colori", che permetteranno di accedere agli stessi prodotti in due modi diversi. La lista deve essere navigabile in entrambe le direzioni (da padre a figlio e da figlio a padre).
	
	\item Quando una linea di prodotto viene selezionata deve essere data la possibilit\`a all'utente di avviare una breve presentazione eseguita dall'\textit{avatar\gloss} sulla linea di prodotto scelta. Questo comporta l'apparazione dell'\textit{avatar\gloss} a schermo.
	
	\item L'applicazione deve dare la possibilit\`a all'utente di visualizzare i prodotti appartenenti a una certa categoria e deve dare la possibilit\`a di selezionarne uno da visualizzare in realt\`a aumentata.
	
	\item L'utente deve avere la possibilit\`a di selezionare un prodotto da una lista di prodotti e di visualizzarlo in realt\`a aumentata agganciato al tag. Alla selezione del prodotto deve, inoltre, essere disponibile la possibilit\`a di visualizzare la descrizione del prodotto scelto in un pannello appositamente creato.
	
	\item L'applicazione deve permettere, quando un prodotto \`e selezionato e visibile in realt\`a aumentata, di effettuare modifiche sulla superficie coperta. In particolare, si vuole rendere disponibile all'utente la funzionalit\`a di \textit{pinch-to-scale} sull'oggetto parquet.
	
	\item l'applicazione rende disponibile un men\`u di "\textit{Credits}" in cui \`e possibile riavviare la presentazione iniziale, rivedere il \textit{tutorial}, oppure collegarsi alla pagina di \textit{download} tag, o alla pagina Facebook ufficiale di Cor\`a Divisione Parquet.
	
	\item L'applicazione deve dare la possibilit\`a all'utente di richiedere un preventivo \textit{online} e di scattare uno screenshot della schermata visualizzata.
	
	\item L'applicazione deve contenere almeno i primi 30 prodotti inviati dall'azienda. 
	
\end{itemize}

\textbf{Requisiti desiderabili:}

\begin{itemize}
	\item L'applicazione deve contenere i 21 prodotti inviati in seconda istanza.
	
	\item L'applicazione deve prevedere le gesture di "\textit{Swipe}" per aprire e chiudere i men\`u.
	
	\item Le \textit{texture\gloss} dei prodotti devono utilizzare uno \textit{shader} speculare per ottenere un'effetto piu lucido.
	
	\item La barra del men\`u di navigazione deve essere ingrandita rispetto alla versione base del configuratore.
	
	\item Gli \textit{screenshot} devono catturare solo la schermata principale con il prodotto in realt\`a aumentata, il pannello descrittivo del prodotto e il logo di Cor\`a Divisione Parquet, niente altro.
\end{itemize}

Come gi\`a descritto in precedenza, i requisiti hanno visto modifiche anche sostanziali ad ogni iterazione, questo perch\`e la pratica adottata \`e stata un'analisi iniziale seguita da una breve progettazione e da un intenso periodo di implementazione. Al termine di tale periodo, avveniva prima una verifica completa e poi compilata una demo ed inviata al cliente. Il cliente visionava l'app e inviava di ritorno al \textit{Project Manager} un \textit{feedback} con le criticit\`a e le migliorie da apportare. Seguiva, quindi un'ulteriore analisi dei requisiti ed iniziava un nuovo ciclo iterativo.\\\\


\subsubsection{Progettazione}
Nella metodologia Agile, la fase di progettazione \`e la pi\`u importante e difficile da realizzare. Serve infatti molta esperienza per lavorare con una metodologia di questo tipo, in quanto il progetto si ritrova soggetto a continui cambiamenti. Risulta quindi difficile una progettazione solida e duratura, e non si ha il tempo necessario per entrare nel dettaglio, in quanto le ore previste per questa attivit\`a sono poche e frequenti.\\
Come gi\`a detto in sezioni precedenti del documento, il configuratore da realizzare doveva partire da un modello di configuratore di base gi\`a realizzato e implementante un \textit{design pattern} architetturale \textit{Model View Controller}, per quanto Unity ne permetta un'implementazione limitata.\\
I \textit{design pattern} sono strumenti che aiutano a risolvere un certo tipo di problema comune. Quindi, \`e necesseria la presenza di un problema per applicare un design pattern che lo risolva.\\
Bisogna sottolineare il fatto che Unity si basa pesantemente attorno alle componenti o ai pi\`u noti "\textit{GameObject}", ovvero gli oggetti di gioco e non c'\`e modo di aggirare questa cosa.\\\\
Segue ora una descrizione di come \`e stato progettato il configuratore comprensivo delle funzionalit\`a di base offerte da un configuratore gi\`a realizzato e delle parti da me costruite.\\


\begin{figure}[H]
	\centering
	\includegraphics[width=1.1\textwidth]{\docsImg Class.png}
	\caption{Diagramma delle classi generico}
	\label{fig:Diagramma delle classi}
\end{figure}
\newpage

In figura \ref{fig:Diagramma delle classi} si pu\`o notare come sia stata organizzata l'architettura dell'applicazione sulla base di ci\`o che era gi\`a stato realizzato. In particolare, necessita una spiegazione l'etimologia dei colori del diagramma:

\begin{itemize}
	\item \textbf{Giallo}: le classi colorate in giallo rappresentano classi gi\`a presenti e realizzate dai colleghi del reparto tecnico a cui non sono state apportate modifiche.
	\item \textbf{Azzurro}: Le classi colorate di azzurro rappresentano le classi gi\`a implementate a cui per\`o \`e stata applicata una modifica non banale.
	\item \textbf{Verde}: in verde le classi create da zero.
\end{itemize}

Come \`e facile notare dal diagramma, il modello di gestione dei prodotti del configuratore era gi\`a implementato in una sorta di MVC. Il mio compito \`e stato quello di adattare il codice gi\`a sviluppato perch\`e si prendesse carico dell'inserimento e della gestione di un nuovo tipo di contenuto. \\
Inoltre, il mio compito principale riguardava la gestione dell'\textit{avatar\gloss} all'interno dell'applicazione e la gestione delle \textit{gesture}.

\paragraph{Architettura generale}
Da subito sono state definite quelle che avrebbero dovuto essere le entit\`a principali all'interno dell'applicazione, ovvero:

\begin{itemize}
	\item \textbf{Product}: Classe rappresentante il modello dati di un prodotto, avente il compito di memorizzare tutte le informazioni relative a un parquet, quali: nome, linea, categoria, finitura, codice, descrizione, essenza, scelta, superficie e dimensioni. Inoltre contiene il nome del padre del prodotto e uno sprite di dimensioni 300x300(px) da usare come icona.
	
	\item \textbf{ProductController}: Questa classe si occupa di istanziare l'oggetto 3D rappresentante il prodotto vero e proprio una volta che un prodotto viene selezionato. Il modello 3D viene caricato e istanziato \textit{runtime} dalle risorse disponibili in base al nome dell'oggetto scelto, che quindi dovr\`a essere univoco tra i vari prodotti e contenere la stringa "\_3d" in coda.
	
	\item \textbf{HierarchyElement}: Classe che si occupa di gestire genitore e figli del prodotto preso in considerazione.
	
	\item \textbf{DataController}: Questa \`e la classe centrale su cui si basa tutto il funzionamento del configuratore. Il compito di questa classe \`e quello di gestire la gerarchia completa di prodotti, permettendo di impostare il nome e l'icona delle varie categorie, e di impostare i genitori e le icone di ogni prodotto. Tutto questo pu\`o essere gestito come \textit{plugin} di Unity semplicemente attaccando lo \textit{script} ad un GameObject vuoto.
	
	\item \textbf{AvatarPositionController}: Classe principale di gestione e controllo dell'\textit{avatar\gloss}. Qui viene gestito il posizionamento dell'\textit{avatar\gloss}: all'avvio dell'applicazione l'\textit{avatar\gloss} viene posizionato sopra il tag ad una grandezza fissata, successivamente, una volta terminata la presentazione iniziale, l'\textit{avatar\gloss} viene spostato e fissato a schermo in una posizione laterale e non troppo ingombrante. Quando l'\textit{avatar\gloss} \`e fissato a schermo ha una scala posta a zero, mentre viene ingrandito una volta richiamato tramite apposito pulsante. Questo \textit{script} si occupa anche di gestire la posizione e l'apparizione del ventaglio iniziale per poi invocare il metodo dedicato alla presentazione vera e propria dell'\textit{avatar\gloss}.
	
	\item \textbf{StartController}: E' la classe che si occupa di gestire la presentazione iniziale dell'\textit{avatar\gloss}. Qui vengono caricati i file audio e temporizzati con l'inizio delle animazioni. La classe si occupa di gestire sia l'avvio sia il termine (anche richiesto dall'utente) dell'applciazione.
	
	\item \textbf{SpeakerAndAnimationController}: Classe realizzata con lo scopo di gestire l'\textit{avatar\gloss} in modo da fargli presentare le categorie tramite animazioni e file audio. Non era conosciuto a priori il numero di animazioni che si sarebbero dovute implementare per cui questa classe doveva essere progettata in modo da gestire un numero indefinito di animazioni e file audio.
	
	\item \textbf{PinchToScale}: Questa classe non si occupa di riconoscere la \textit{gesture}, compito dedicato a una classe sviluppata da terzi, ma si occupa di definire il comportamento quando viene rilevata una particolare \textit{gesture} sul modello 3D del prodotto.
	
	\item \textbf{SwipeManager}: Questa classe, come la precedente, non \`e un riconoscitore di \textit{gesture} ma un gestore che si occupa di definirne il comportamento. Lo SwipeManager deve aprire e chiudere i men\`u in base al tipo di \textit{swipe} effettuato.
	
	\item \textbf{ScreenshotManager}: Si occupa di gestire la cattura e il salvataggio della schermata visualizzata dul \textit{display}. Lo \textit{script} si affita all'utilizzo di classi dedicate sviluppate da terzi e ha il compito di gestire cosa deve essere visualizzato nello \textit{screenshot}.
	
	\item \textbf{CoraMailBuilder}: E' lo \textit{script} che si occupa della creazione della e-mail di richiesta preventivo su un determinato prodotto.
	
	\item \textbf{LevelBehaviour}: Questa classe si occupa di popolare il men\`u inferiore dell'applicazione, creando i pulsanti per ogni categoria e i pulsanti relativi ai prodotti.
\end{itemize}

Questi sono gli \textit{script} principali utilizzati nella realizzazione del progetto. Come gi\`a detto, sono stati creati altri \textit{script} pi\`u dedicati e di rifinitura, la cui spiegazione in dettaglio non far\`a parte di questo documento per non appesentirne la lettura.\\\\

\paragraph{\textit{Layout} e GUI\gloss}
Per quanto riguarda la GUI\gloss\ dell'applicazione, essa \`e stata progettata da terzi per conto di Cor\`a Divisione Parquet e mi \`e stata inviata tramite un file PSD\gloss\ contenente le grafiche da utilizzare e il \textit{layout} a cui adeguarsi.\\
Il \textit{layout} \`e stato scelto sulla base dei configuratori precedentemente utilizzati ed \`e stato adattato per il progetto specifico.

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{\docsImg layout1.jpg}}
	\caption{Layout con menu' info aperto}
	\label{fig:Layout con menu info aperto}
\end{figure}

\begin{figure}[H]
	\centering
	\fbox{\includegraphics[width=1\textwidth]{\docsImg layout2.jpg}}
	\caption{Layout con menu inferiore aperto}
	\label{fig:Layout con menu inferiore aperto}
\end{figure}
\newpage
Di seguito vengono descritti i componenti principali della GUI\gloss .

\begin{itemize}
	\item \textbf{Logo}: il logo \`e un pulsante cliccabile che apre il men\`u dei \textit{Credits} nel centro dello schermo;
	\item \textbf{Men\`u inferiore}: contiene la lista delle categorie, con eventualmente la relativa icona, e la lista dei prodotti come figli della propria categoria madre. Il men\`u \`e composto da una \textit{breadcumb} navigabile, e da una sequenza di bottoni assegnati ognuno ad una categoria, e nei livelli pi\`u profondi ai prodotti.
	\item \textbf{Pannello Info}: \`e un pannello laterale che compare dopo la pressione del pilsante "i". Il pulsante in questione diventa visibile solo quando un prodotto \`e selezionato e permette di aprire la sezione relativa alla descrizione del prodotto. Il pannello si compone anche di un pulsante per l'acquisizione di \textit{screenshot} e un pulsante per la richiesta di preventivo del prodotto visualizzato.
	\item \textbf{Pulsante animazione}: \`e un pulsante a forma di fumetto situato nella parte a est dello schermo, e diventa visibile ogni volta che l'avatar\gloss ha qualcosa da dire. Nello specifico, compare quando viene selezionata una categoria interna alle "linee di prodotto", e scompare negli altri casi. La comparsa \`e seguita da un'animazione di notifica per richiamare l'attenzione dell'utente. Una volta premuto il pulsante, compare l'\textit{avatar\gloss} nella parte ovest dello schermo iniziando l'animazione dedicata.
	\item \textbf{\textit{Scope}}: mirino posizionato al centro dello schermo e utilizzato per fornire brevi istruzioni all'utente su cosa fare e dare la possibilit\`a all'utente di scaricare il tag, oltre al fatto di eseguire la sua funzionalit\`a principale di supporto per mirare il tag.
\end{itemize}

L'apertura del men\`u, dei credits e del pannello laterale non \`e mutualmente esclusiva, in quanto tutte e tre le componenti possono essere visibili in stato aperto contemporaneamente senza interferire tra di loro.\\


In questo capitolo ho avuto voce, in quanto ho potuto esprimere il mio dissenso su alcune scelte relative all'usabilit\`a dell'applicazione mantenedo un certo tipo di \textit{layout}. Queste osservazioni e richieste di modifica della grafica sono state concordate prima con \textit{Project Manager} e successivamente con il cliente. Le modifiche osservate e accolte sono state:

\begin{itemize}
	\item Grandezza del pannello delle informazioni laterali. Essendo troppo piccolo risulatava inutilizzabile da \textit{smartphone}.
	\item Stile dell'icona dell'applicazione che risultava poco leggibile.
	\item Posizione del pulsante animazione. Inizialmente posto nella parte superiore dello schermo, risultava difficile da raggiungere con un'impugnatura \textit{standard} del \textit{device}.
\end{itemize}

Inoltre, ho proposto l'utilizzo di un tag di grandezza A3, al posto del foglio A4 utilizzato per ottenere un migliore risultato di agganciamento del tag e di \textit{tracking}. Questa richiesta non \`e stata accolta in quanto si presuppone la stampa domestica del tag in assenza di possibilit\`a di stampare fogli A3.\\


\paragraph{\textit{Animator Controller}}
Gli \textit{Animator Controller} sono i gestori delle animazioni di un GameObject in Unity. Generalmente, ogni oggetto che si vuole animare ha attaccato un \textit{Animator} con associato un \textit{Animator Controller} che ne definisce il comportamento. In questo progetto, tali componenti hanno avuto un ruolo fondamentale, per cui \`e stata necessaria un'attenta progettazione di queste componenti.\\
In questo paragrafo verranno tralasciate le spiegazioni degli \textit{Animation Controller} banali.\\

\begin{itemize}
	\item \textbf{\textit{Info Panel Controller}}: \textit{controller} dedicato al pannello laterale per gestire le animazioni entrata, uscita e di oscurazione del pulsante "i". Esempio utile per capire come ogni oggetto della GUI\gloss\ \`e stato gestito in modo simile. Ogni animazione viene fatta partire al cambio di stato di un valore booleano oppure all'azionamento di un particolare\textit{ trigger}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\textwidth]{\docsImg InfoPanelController.png}
		\caption{\textit{Animator Controller} del pannello Info laterale}
		\label{fig:Animator Controller del pannello Info laterale}
	\end{figure}
	
	Nel dettaglio: INFO\_DEF nasconde sia pannello che pulsante, INFO\_HIDE mostra il pulsante "i", INFO\_SHOW apre il pannello su schermo, INFO\_SHOT, rimuove gli elementi della GUI\gloss\ indesiderati per l'esecuzione di uno \textit{screenshot}.
	
	\item \textbf{\textit{Avatar Speaker Controller}}: dedicato alla gestione della presentazione iniziale da parte dell'\textit{avatar\gloss} e alle animazioni relative alla spiegazione delle categorie.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\textwidth]{\docsImg AvatarSpeakerController.png}
		\caption{\textit{Animator Controller} dell'\textit{avatar\gloss}}
		\label{fig:Animator Controller dell'avatar\gloss}
	\end{figure}
	
	Nel dettaglio: IDLE \`e lo stato iniziale, a cui l'\textit{avatar\gloss} ritorna alla fine di ogni presentazione. Lo stato PRESENTATION \`e un particolare stato in cui l'\textit{animator} viene portato nel momento in cui si vuole avviare la presentazione iniziale. Questo stato termina poi con il passaggio a END\_PRESENTATION che \`e uno stato necessario per effettuare alcuni controlli da codice, come controllare che la presentazione sia terminata. Lo stesso viene fatto con le \textit{n} categorie di prodotti di cui si ha la presentazione.\\ Questo \textit{animator} poteva essere implementato in modo pi\`u efficiente caricando l'animazione da fare partire di volta in volta in base ad una stringa passata. Avendo tempo limitato ho preferito procedere per una strada di facile implementazione come questa.
\end{itemize}






\subsubsection{Implementazione}
L'attivit\`a di implementazione e di codifica si \`e svolta secondo quanto previsto dalla metodologia Agile. Le fasi di codifica non son avvenute in un unico \textit{round}, ma in brevi e frequenti blocchi di tempo. Per prima cosa, sono state implementate le parti principali del sistema, cio\`e le parti che quasi sicuramente non avrebbero avuto modifiche nelle successive iterazioni.\\

Ho proceduto, in primo luogo, con l'adattamento di quanto disponibile nel configuratore base. In particolare ho creato una classe \textit{Product} in grado di contenere tutte le informazioni necessarie per ogni prodotto.\\

\paragraph{\textit{Pinch-To-Scale}}
E' stata richiesta la possibilit\`a di espandere il parquet mostrato in realt\`a aumentata direttamente \textit{runtime} tramite l'applicazione di una \textit{gesture} dedicata.\\
Bisogna premettere che le \textit{texture\gloss} dei parquet sono state recapitate simulandone la grandezza reale per cui, data anche l'irregolarit\`a di alcuni parquet, era difficile fare il \textit{tiling} (ripetizione della \textit{texture\gloss} su uno o pi\`u assi) della \textit{texture\gloss}.\\
Su suggerimento del CTO ho deciso di procedere mantenedo la dimensione reale della \textit{texture\gloss}, senza \textit{tiling}, e applicando una maschera ridimensionabile all'oggetto in modo tale da visualizzarne solo una parte. La realizzazione \`e stata affidata completamente a me.\\
Ho creato una maschera a forma di cornice, unendo pi\`u oggetti tridimensionali prefabbricati. A tale maschera ho, poi, applicato un particolare \textit{shader} in grado di rimuovere il \textit{rendering} delle parti di \textit{texture\gloss} coperte dalla maschera.\\
Di seguito \`e illustrata la codifica relativa allo \textit{script} \textit{PinchToScale}.\\
\noindent
\textbf{1. PinchToScale.cs}

\begin{lstlisting}

public class PinchToScale : MonoBehaviour
{
public Vector3 scaleWeights = Vector3.one;
public float minScaleAmount = 0.4f;
public float maxScaleAmount = 4.0f;
public float sensitivity = 0.3f;		// augment for a bigger scaling
public float smoothingSpeed = 12.0f;    // set to 0 to disable smoothing
public GameObject mask;

private float idealScaleAmount = 0.4f;
private float scaleAmount = 0.4f;
private Vector3 baseScale = Vector3.one;

public float ScaleAmount
{
	get { return scaleAmount; }
	
	set 
	{ 
		value = Mathf.Clamp( value, minScaleAmount, maxScaleAmount );	//check if the value is between limits
		
		if( value != scaleAmount )
		{
			scaleAmount = value;
			
			Vector3 s = scaleAmount * baseScale;
			s.x *= scaleWeights.x;
			s.y *= scaleWeights.y;
			s.z *= scaleWeights.z;
			
			mask.transform.localScale = s;			//resize the mask scale
		}
	}
}

public float IdealScaleAmount
{
	get { return idealScaleAmount; }
	set { idealScaleAmount = Mathf.Clamp( value, minScaleAmount, maxScaleAmount ); }
}

void Start()
{
	baseScale = transform.localScale;
	IdealScaleAmount = ScaleAmount;
}

void Update()
{
	if (smoothingSpeed > 0) {
		ScaleAmount = Mathf.Lerp (ScaleAmount, IdealScaleAmount, Time.deltaTime * smoothingSpeed);
	} else {
	ScaleAmount = IdealScaleAmount;
}
}

void OnPinch( PinchGesture gesture )
{  
	IdealScaleAmount += sensitivity * gesture.Delta.Centimeters();
} 
\end{lstlisting}

Il codice, all'avvio dello \textit{script}, memorizza la scala locale dell'oggetto, e imposta il valore di \textit{scaling} ideale allo \textit{scaling} di base. Ad ogni \textit{frame} viene aggiornato, internamente al metodo \textit{Update()}, lo \textit{scaling} attuale, sia nel caso sia presente un effetto di \textit{smooth} sia altrimenti. Quando viene catturata una \textit{gesture} di \textit{Pinch}, ne viene presa l'ampiezza in centimetri e moltiplicata per la sensibilit\`a che gli si vuole dare allo \textit{scaling} rispetto alla \textit{gesture}. Questo valore calcolato viene memorizzato in IdealScaleAmount che nel successivo \textit{Update} sar\`a memorizzato come nuovo valore di ScaleAmount. ScaleAmount ogni volta che viene modificato si occupa di applicare lo \textit{scaling} impostato alla maschera passata come parametro da Unity.\\\\


\paragraph{Inserimento prodotti}
Successivamente ho proceduto con l'inserimento dei primi 20 prodotti, in quanto il modello e la gestione delle categorie e dei prodotti era gi\`a implementata. Per ogni prodotto, prima, ho dovuto importare negli \textit{asset\gloss} la relativa \textit{texture\gloss} e icona, poi, dopo aver attaccato uno \textit{script} Product al prodotto comprensivo del modello 3D, questo veniva processato in uno script (\textit{VariationMaker.cs}) che creava 2 oggetti: un \textit{GameObject} contenente le informazioni del prodotto da utilizzare nello \textit{script} di gestione dei dati (\textit{DataController.cs}) e un \textit{GameObject} con il modello 3D.\\

\paragraph{Gestione dell'\textit{avatar\gloss}}
Come gi\`a accennato, il grosso del lavoro consistava nell'implementazione di un \textit{avatar\gloss} all'interno dell'applicazione. Per prima cosa ho gestito la presentazione iniziale composta da 4 file di animazione e 4 file audio. E' stata usata la tecnica del \textit{lip sync} per ottenere un effetto realistico. Di ci\`o se ne \`e occupato lo \textit{StartController} sviluppato appositamente.\\
Lo \textit{StartController} \`e stato implementato utilizzando il \textit{design pattern} Singleton in quanto era necessario avere al pi\`u un'istanza della classe.\\

	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.4\textwidth]{\docsImg ava.jpg}
		\caption{Presentazione iniziale}
		\label{fig:Presentazione iniziale}
	\end{figure}


All'avvio dello \textit{StartController} vengono caricati in memoria gli audio file relativi alla presentazione. Durante ogni ciclo di \textit{Update}, invece, viene controllato lo stato dell'animazione corrente e il numero contenuto all'interno di un particolare contatore. In questo modo \`e possibile eseguire nell'ordine corretto i vari pezzi ottenendo, cosi, l'animazione completa, senza che venga ciclata pi\`u volte essendo che il contatore procede verso un'unica direzione incrementale e viene ripristinato solo quando si vuole riavviare la presentazione.\\

Di seguito viene mostrata la codifica del metodo \textit{Awake()} che si occupa del caricamento dei file audio.
\\\\
\textbf{2. StartController.cs - Metodo Awake()}
\begin{lstlisting}
	void Awake() {
		_instance = this;
		pt1 = (AudioClip)Resources.Load ("Speakeraggio/01_Presentazione1", typeof(AudioClip));
		pt2 = (AudioClip)Resources.Load ("Speakeraggio/02_Presentazione2", typeof(AudioClip));
		pt3 = (AudioClip)Resources.Load ("Speakeraggio/03_Presentazione3", typeof(AudioClip));
		pt4 = (AudioClip)Resources.Load ("Speakeraggio/04_Presentazione4", typeof(AudioClip));
	}
\end{lstlisting}

E il metodo \textit{Update()} che si occupa della gestione delle animazioni e della sincronizzazione con i file audio. Inoltre, si pu\`o notare come venga reso disponibile un pulsante "\textit{Skip}" per saltare la presentazione.
\\\\
\textbf{3. StartController.cs - Metodo Update()}
\begin{lstlisting}
	void Update(){
		if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("01_Presentazione1") && startLock == 1) {
			presentationAudio.clip = pt1;
			presentationAudio.Play();
			skipButton.SetActive(true);
			skipButton.GetComponent<Animator> ().SetBool ("Show", true);
			startLock++;
		}
		if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("02_Presentazione2") && startLock == 2) {
			presentationAudio.clip = pt2;
			presentationAudio.Play();
			startLock++;
		}
		if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("03_Presentazione3") && startLock == 3) {
			presentationAudio.clip = pt3;
			presentationAudio.Play();
			startLock++;
		}
		if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("04_Presentazione4") && startLock == 4) {
			presentationAudio.clip = pt4;
			presentationAudio.Play();
			startLock++;
		}
		if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("EndPresentation") && startLock == 5) {
			EndPresentation ();
			startLock = 1;
		}
	
	}
\end{lstlisting}

Il passo di implementazione successivo \`e stato la gestione della posizione dell'\textit{avatar\gloss}. All'inizio doveva risultare agganciato al tag per poi spostarsi e rimanere agganciato alla parte ovest dello schermo, comparendo solo su richiesta.\\
Questo \textit{script} \`e quello che pi\`u ha usufruito della metodologia Agile, e in particolare quello che ha subito pi\`u incrementi nelle varie iterazioni.\\
Questo perch\`e il cliente, non essendo un esperto di realt\`a aumentata e, soprattutto di applicazioni Android, non aveva un'idea precisa di come e dove dovesse apparire l'\textit{avatar\gloss}. Per cui sono state richieste numerose prove per ottenere il risultato che pi\`u rendesse felice il cliente.\\
In iterazioni intermedie avevo previsto un'interessante funzionalit\`a per cui il \textit{device} calcolava l'altezza rispetto al tag e modificava la grandezza dell'\textit{avatar\gloss} per una visione "da alzati" e una "da seduti". Questa funzionalit\`a da me realizzata \`e piaciuta molto al \textit{team} di sviluppo ma \`e stata bocciata dal cliente finale che, alla fine, \`e stato convinto dal \textit{Project Manager} ad adottare la soluzione ottimale consistente nell'\textit{avatar\gloss} di grandezza fissa.\\
Questo \textit{script} \`e fondamentale perch\`e gestisce le animazioni dei vari componenti che agiscono nella presentazione iniziale e le sincronizza per ottenere il miglior effetto visivo.
Anche per l'implementazione di questo \textit{script} \`e stato utilizzato un \textit{design pattern} Singleton per permettere al pi\`u una sola istanza disponibile.\\\\

L'ultimo \textit{script} realizzato per il controllo dell'\textit{avatar\gloss} \`e lo \textit{script} che si occupa di gestire le presentazioni delle varie categorie, chiamato \textit{SpeakerAndAnimationController}. Anche in questo \textit{script} \`e stato usato il \textit{design pattern} Singleton.\\
Nel dettaglio, il pulsante di una categoria invoca, alla pressione, un metodo chiamato \textit{SetPresentation(string)} che si occupa di caricare in memoria l'audio corrispondente effettuando una ricerca per nome negli \textit{asset\gloss}. Nel caso la ricerca termini correttamente viene mostrato il pulsante animazione (pulsante a forma di fumetto), altrimenti viene nascosto, se gi\`a visibile, o non mostrato, se gi\`a invisibile.\\
Alla pressione del pulsante animazione viene invocato un metodo dedicato allo start e allo stop della presentazione. In particolare, se esiste gi\`a un'audio e un'animazione in esecuzione da parte dell'\textit{avatar\gloss}, e viene premuto tale pulsante, l'animazione viene fermata. Se invece  non \`e presente alcuna presentazione in esecuzione, viene fatto partire l'audio in memoria con la relativa animazione, facendo comparire l'\textit{avatar\gloss} con un effetto di \textit{scaling out}.\\
E' utile osservare il funzionamento del metodo \textit{Update()} per capire come avviene la sincronizzazione tra audio e animazione.
\\\\
\textbf{4. SpeakerAndAnimationController.cs - Metodo Update()}
\begin{lstlisting}
void Update(){
	if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("EndSpeech")) {
		StartCoroutine(scaleIn( new Vector3 (100f, 100f, 100f), new Vector3(0f,0f,0f), 1.5f));
		hasAudioBeenPlayed = false;
		instance.resetAnimation (active);
	}
	if (avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName ("Idle") && active != "") {
		AudioClip audio = (AudioClip)Resources.Load ("Speakeraggio/" + active, typeof(AudioClip));
		activeAudio.clip = audio;
	}
	if (!hasAudioBeenPlayed && !string.IsNullOrEmpty(active) && avatar\glossController.GetCurrentAnimatorStateInfo (0).IsName (active)) {
		hasAudioBeenPlayed = true;
		activeAudio.Play ();
	}
}
\end{lstlisting}

Come si pu\`o notare, viene fatto un controllo sullo stato in esecuzione dell'\textit{animator controller}. In particolare, se ci si trova in uno stato di fine presentazione, viene data la possibilit\`a di far partire un nuovo audio e viene nascosto l'\textit{avatar\gloss}.
Se l'\textit{avatar\gloss} si trova nello stato iniziale, viene caricato l'audio corrente, mentre se l'animazione relativa all'audio \`e attiva e l'audio pu\`o essere eseguito viene effettuato un play, che avviene in modo sincronizzato con l'animazione.\\

\paragraph{Gestione della GUI\gloss}
La GUI\gloss \`e l'aspetto del progetto che pi\`u ha subito modifiche. Inizialmente, per trovare la resa grafica migliore a livello estetico e, successivamente, per garantire il pi\`u alto livello possibile di usabilit\`a. Il problema principale \`e stato identificare il contesto di utilizzo dell'applicazione e decidere se ottimizzare l'interfaccia per \textit{smartphone} o per \textit{tablet}, in quanto la creazione di due interfacce ad-hoc avrebbe avuto un costo aggiuntivo per il cliente. Si \`e deciso di ottimizzare l'app per \textit{smartphone}, in quanto tecnologia pi\`u reperibile. Lo sviluppo della GUI\gloss\ \`e avvenuto seguendo come linea guida un file PSD\gloss\ contenente le varie schermate e da cui era possibile prendere le grafiche (icone, pulsanti, etc.)

\paragraph{Implementazione del \textit{tutorial}}
Come ultimo passo di implementazione, ho proceduto con la creazione del tutorial, prendendo le grafiche da una sezione del file PSD\gloss\ dedicato e modificando del codice gi\`a creato per configuratori precedentemente realizzati. Il \textit{tutorial} \`e stato pensato in modo tale da procedere con l'avanzamento grazie ad un \textit{tap} sullo schermo ed \`e stata prevista una funzionalit\`a per saltare il \textit{tutorial} ed andare direttamente alla parte del configuratore.

\subsubsection{Verifica e validazione}
L'attivit\`a di verifica \`e' stata svolta durante tutto il periodo di sviluppo del progetto e, in particolare, al termine di ogni iterazione, secondo quanto previsto dall'implementazione della metodologia Agile.\\ 
Come gi\`a detto, nella metodologia Agile, le risorse dedicate alla scrittura di documentazione e alla attivita' di progettazione sono poche. Per cui, anche le attivita' di verifica sono state svolte relativamente al codice, tralasciando gli aspetti secondari.
Ci\`o significa che durante la fase di codifica ho eseguito, inizialmente, una breve ma mirata analisi statica composta da:

\begin{itemize}
	\item \textbf{Analisi di flusso di controllo}: ho controllato che il codice scritto fosse eseguito nella sequenza specificata e mi sono accertato del fatto che non ci fosse codice non raggiungibile, oppure segmenti di esecuzione non terminanti.
	\item \textbf{Analisi di flusso dei dati}: ho controllato che tutte le variabili fossero inizializzate correttamente e che non ci fossero variabili prive di valore.
	\item \textbf{Analisi di limite}: ho verificato che tutti i dati da me usati restassero entro i limiti del loro tipo e della precisione desiderata.
\end{itemize}

Altri tipi di analisi statica sarebbero stati difficili da implementare, in quanto, essendo Unity un motore di gioco risulta molto pi\`u semplice ed economico, dal punto di vista delle risorse utilizzate, effettuare un'analisi dinamica del codice.\\\\

Ho proceduto quindi, in secondo luogo, con l'applicazione di tecniche di analisi dinamica, al termine di ogni significativa attivita' di codifica producente materiale testabile.\\
Con l'aiuto di un \textit{plugin} di Vuforia per Unity, \`e stato possibile utilizzare una webcam per simulare il comportamento della fotocamera dei \textit{device} ed evitare, quindi, lunghe attese dovute alla compilazione dell'applicazione.\\
Per l'analisi dinamica mi sono servito, per prima cosa, dell'utilizzo di \textit{log}, in modo da verificare il corretto stato di ogni variabile e la corretta esecuzione dei metodi. Questo, quando possibile \`e stato verificato tramite l'opzione "\textit{Play}" di Unity che permette l'esecuzione dell'applicazione direttamente sul PC. Per testare moduli richiedenti particolari funzionalit\`a presenti esclusivamente su \textit{device}, invece, ho proceduto sempre con l'utilizzo di \textit{log}, ma compilando l'applicazione ed eseguendola direttamente su \textit{device}.\\
Grazie all'utilizzo di Cygwin ho potuto visualizzare i \textit{log} di sistema di Android e i \textit{log} da me creati. Questa metodologia \`e stata utilizzata principalmente per la verifica della corretta implementazione delle \textit{gesture}, quali il \textit{Pinch-To-Scale} e lo \textit{Swipe}.\\
Cygwin \`e una distribuzione di \textit{software\gloss} libero che consente a diverse versioni di Microsoft Windows di svolgere alcuni compiti esteticamente e funzionalmente simile ad un sistema Linux.\\\\
Alla fine di ogni iterazione, infine, alcuni componenti del \textit{team} tecnico si occupavano di verificare e validare l'applicazione per confermare il soddisfacimento dei requisiti richiesti per tale revisione. Questi \textit{test} venivano svolti tramite un'esecuzione dell'applicazione su diversi tipi di device andando a testare il corretto funzionamento delle componenti implementate.

I \textit{device} utilizzati per il \textit{testing} dell'applicazione sono stati:

\begin{itemize}
	\item Google Nexus 5 (Android);
	\item Samsung Note 4 (Android):
	\item Samsung Galaxy S3 (Android);
\end{itemize}

Una volta completato il progetto abbiamo proceduto, io e la squadra tecnica, con una validazione interna dell'applicazione e, vista l'assenza di \textit{bug}, con un rilascio in beta al cliente.\\
Il cliente ha proceduto con l'esecuzione dei propri \textit{test} e fornendoci \textit{feedback} positivi permettendoci di effettuare il \textit{release} dell'app sui vari \textit{store}.\\

\subsection{Livello di completezza raggiunto}
In definitiva, e' stata realizzata un'applicazione configuratore in realt\`a aumentata dedicata alla visualizzazione di parquet in legno in un contesto domestico. L'applicazione si compone di un men\`u inferiore dedicato alla ricerca e selezione dei prodotti in base alla loro categoria o in base al loro colore. Un prodotto selezionato viene reso visibile agganciato al tag e viene reso disponibile un men\`u laterale in cui e' possibile leggere le informazioni del prodotto, scattare \textit{screenshot} e richiedere un preventivo relativo al parquet selezionato.\\\\
\noindent
Il men\`u inferiore risulta composto da due sezioni:

\begin{itemize}
	\item \textbf{\textit{Breadcumb}}: posizionata sulla parte superiore del men\`u, rappresenta il percorso seguito all'interno della gerarchia delle categorie. Ogni \textit{step} della \textit{breadcumb} e' un pulsante cliccabile che permette il ritorno al livello selezionato.
	\item \textbf{\textit{Slider}}: la parte inferiore e' una lista orizzontale di categorie o prodotti, in base al livello della gerarchia in cui ci si trova. Questa lista e' composta da pulsanti cliccabili aventi un nome significativo e, per tutti i prodotti e alcune categorie, anche un'icona rappresentativa.
\end{itemize}
\noindent
Il pannello laterale, che compare solo alla selezione di un prodotto, e' composto invece da:

\begin{itemize}
	\item \textbf{Icona}: posta nella parte superiore, consiste in una rappresentazione grafica del parquet selezionato;
	\item \textbf{Descrizione}: seguono una lista di informazioni riguardanti: nome, categoria, linea, essenza, scelta e dimensioni;
	\item \textbf{Pulsanti utili}: in fondo al pannello sono presenti due pulsanti: uno per la cattura di uno \textit{screenshot} e uno per la richiesta di preventivo via e-mail;
\end{itemize}
\noindent
Al centro dello schermo \`e presente un mirino che scompare quando si inquadra il tag, il cui scopo \`e quello di guidare l'utente con alcuni \textit{tips} e di aiutare ad inquadrare correttamente il tag. E' presente anche un pulsante che permette il \textit{download} del tag, posto a nord-est del mirino.\\\\

Premendo il logo, posto nella parte superiore dello schermo, si accede al men\`u dei \textit{Credits}. Questo men\`u, oltre ad alcune informazioni riguardanti lo sviluppo dell'applicazione, rende disponibili alcuni pulsanti utili:

\begin{itemize}
	\item un pulsante che serve a rivedere la presentazione iniziale;
	\item un pulsante per avviare il \textit{tutorial} iniziale;
	\item un pulsante per scaricare il tag;
	\item un pulsante dedicato all'apertura della pagina Facebook di Cora' Divisione Parquet.
\end{itemize}

L'applicazione si completa con una presentazione iniziale da parte dell'\textit{avatar\gloss} (il cui nome \`e Arte) e con la possibilita' di richiamarlo su schermo ogni volta che ha qualcosa da dire tramite un apposito pulsante posto nella parte laterale dello schermo.\\\\

\noindent
Alla fine del tempo di stage si pu\`o stimare un completamento del progetto quasi totalitario, in quanto l'ultima richiesta da parte del cliente prima della pubblicazione dell'app \`e stata quella di implementare il \textit{follow} di occhi e testa dell'\textit{avatar\gloss} rispetto alla telecamera. Questo ultimo aspetto \`e stato sviluppato interamente da un collega del reparto tecnico dopo la conclusione del mio stage.\\